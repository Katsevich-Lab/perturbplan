---
title: "Prospective Power Analysis Beyond the Web App"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Prospective Power Analysis Beyond the Web App}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "vignettes/figures/prospective-power-",
  out.width = "100%",
  fig.width = 7,
  fig.height = 5
)
```

This vignette demonstrates advanced prospective power analysis workflows that go beyond the web application's built-in functionality. We'll explore:

1. **Comparing perturb-seq and TAP-seq technologies** for the same biological question
2. **Comparing pre-existing experimental designs** instead of designing from scratch
3. **Visualizing expression distributions and saturation curves** to understand the underlying models

```{r setup}
library(perturbplan)
library(ggplot2)
library(dplyr)
library(tidyr)
```

## 1. Comparing Perturb-seq and TAP-seq Technologies

One common question is whether to use standard perturb-seq (whole transcriptome) or TAP-seq (targeted amplification and sequencing) for a specific experiment. We can compare these technologies using the two pilot datasets: the Gasperini et al. (2019) perturb-seq data and the Ray et al. (2025) TAP-seq data.

### Load Pilot Data

First, let's load the K562 perturb-seq pilot data and the K562 TAP-seq pilot data that comes with the package:

```{r load-data}
# Load K562 pilot data
pilot_data <- get_pilot_data_from_package("K562")

# Extract components
baseline_expression <- pilot_data$baseline_expression_stats
library_params <- pilot_data$library_parameters
mapping_efficiency <- pilot_data$mapping_efficiency

# View data structure
str(baseline_expression)
cat("Number of genes:", nrow(baseline_expression), "\n")
str(library_params)
str(mapping_efficiency)

# load the K562 TAP-seq pilot data
tapseq_data <- data("K562_Ray")

# Extract TAP-seq components
tapseq_baseline_expression <- K562_Ray$baseline_expression_stats
tapseq_library_params <- K562_Ray$library_parameters
tapseq_mapping_efficiency <- K562_Ray$mapping_efficiency

# View TAP-seq data structure
str(tapseq_baseline_expression)
cat("Number of genes:", nrow(tapseq_baseline_expression), "\n")
str(tapseq_library_params)
str(tapseq_mapping_efficiency)
```

### Key Differences Between Technologies

The two technologies differ in several important ways:

1. **Gene coverage**: Perturb-seq measures ~20,000 genes genome-wide, while TAP-seq focuses on a targeted panel of ~300 genes
2. **Mapping efficiency**: TAP-seq has higher mapping efficiency to the target gene panel (~70%) compared to perturb-seq (~30%)
3. **Library parameters**: TAP-seq shows lower UMI_per_cell and higher variation in PCR amplification compared to perturb-seq

### Power Comparison

Suppose we use TAP-seq and perturb-seq to analyze the same set of pairs targeting at the TAP-seq genes. Let's first compare how the overall power scales with sequencing depth for both technologies, fixing the number of cells at 2,000 per gRNA target:

```{r compare-read-depths, fig.width=8, fig.height=5}
# Define read depth range
read_depths <- c(10000, 20000, 40000, 80000, 1600000)
cells_per_target <- 500

# Experimental parameters
MOI <- 10
num_targets <- 100
minimum_fold_change <- 0.8
prop_non_null <- 0.005
multiple_testing_alpha <- 0.1
TPM_threshold <- 0.1

# Gene list we consider 
gene_list <- tapseq_baseline_expression$response_id

comparison_results_reads <- list()

for (i in seq_along(read_depths)) {
  reads <- read_depths[i]

  set.seed(123)

  # Perturb-seq power
  # only keep the genes in the TAP-seq panel
  baseline_expression_on_gene_list <- baseline_expression %>%
    filter(response_id %in% gene_list)
  power_ps <- compute_power_plan(
    baseline_expression_stats = baseline_expression_on_gene_list,
    library_parameters = library_params,
    cells_per_target = cells_per_target,
    reads_per_cell = reads,
    MOI = MOI,
    num_targets = num_targets,
    control_group = "complement",
    side = "left",
    prop_non_null = prop_non_null,
    multiple_testing_alpha = multiple_testing_alpha,
    TPM_threshold = TPM_threshold,
    minimum_fold_change = minimum_fold_change
  )

  # TAP-seq power
  power_ts <- compute_power_plan(
    baseline_expression_stats = tapseq_baseline_expression,
    library_parameters = tapseq_library_params,
    cells_per_target = cells_per_target,
    reads_per_cell = reads,
    MOI = MOI,
    num_targets = num_targets,
    control_group = "complement",
    side = "left",
    prop_non_null = prop_non_null,
    multiple_testing_alpha = multiple_testing_alpha,
    TPM_threshold = TPM_threshold,
    minimum_fold_change = minimum_fold_change
  )

  comparison_results_reads[[i]] <- data.frame(
    Reads_per_Cell = reads,
    Technology = c("Perturb-seq", "TAP-seq"),
    Overall_Power = c(power_ps$overall_power, power_ts$overall_power)
  )
}

comparison_reads_df <- bind_rows(comparison_results_reads)

# Plot overall power vs read depth
ggplot(comparison_reads_df, aes(x = Reads_per_Cell, y = Overall_Power,
                          color = Technology, linetype = Technology)) +
  geom_line(linewidth = 1) +
  geom_point(size = 3) +
  scale_x_continuous(labels = scales::comma) +
  scale_y_continuous(labels = scales::percent) +
  labs(
    title = "Technology Comparison: Power vs Sequencing Depth",
    subtitle = sprintf("%s cells per target, FC = %.2f, FDR = %.0f%%",
                      scales::comma(cells_per_target), minimum_fold_change,
                      multiple_testing_alpha * 100),
    x = "Reads per Cell",
    y = "Overall Power",
    color = "Technology",
    linetype = "Technology"
  ) +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    plot.title = element_text(face = "bold"),
    panel.grid.minor = element_blank()
  )
```

Then, let's compare how power scales with the number of cells per target, fixing sequencing depth at 40,000 reads per cell:

```{r compare-cell-numbers, fig.width=8, fig.height=5}
# Define cell number range
cell_numbers <- c(200, 500, 1000, 2000, 4000)
reads_per_cell <- 40000

comparison_results_cells <- list()

for (i in seq_along(cell_numbers)) {
  cells <- cell_numbers[i]

  set.seed(123)

  # Perturb-seq power
  power_ps <- compute_power_plan(
    baseline_expression_stats = baseline_expression_on_gene_list,
    library_parameters = library_params,
    cells_per_target = cells,
    reads_per_cell = reads_per_cell,
    MOI = MOI,
    num_targets = num_targets,
    control_group = "complement",
    side = "left",
    prop_non_null = prop_non_null,
    multiple_testing_alpha = multiple_testing_alpha,
    TPM_threshold = TPM_threshold,
    minimum_fold_change = minimum_fold_change
  )

  # TAP-seq power
  power_ts <- compute_power_plan(
    baseline_expression_stats = tapseq_baseline_expression,
    library_parameters = tapseq_library_params,
    cells_per_target = cells,
    reads_per_cell = reads_per_cell,
    MOI = MOI,
    num_targets = num_targets,
    control_group = "complement",
    side = "left",
    prop_non_null = prop_non_null,
    multiple_testing_alpha = multiple_testing_alpha,
    TPM_threshold = TPM_threshold,
    minimum_fold_change = minimum_fold_change
  )

  comparison_results_cells[[i]] <- data.frame(
    Cells_per_Target = cells,
    Technology = c("Perturb-seq", "TAP-seq"),
    Overall_Power = c(power_ps$overall_power, power_ts$overall_power)
  )
}

comparison_cells_df <- bind_rows(comparison_results_cells)

# Plot overall power vs cell number
ggplot(comparison_cells_df, aes(x = Cells_per_Target, y = Overall_Power,
                          color = Technology, linetype = Technology)) +
  geom_line(linewidth = 1) +
  geom_point(size = 3) +
  scale_x_continuous(labels = scales::comma) +
  scale_y_continuous(labels = scales::percent) +
  labs(
    title = "Technology Comparison: Power vs Cell Numbers",
    subtitle = sprintf("%s reads per cell, FC = %.2f, FDR = %.0f%%",
                      scales::comma(reads_per_cell), minimum_fold_change,
                      multiple_testing_alpha * 100),
    x = "Cells per Target",
    y = "Overall Power",
    color = "Technology",
    linetype = "Technology"
  ) +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    plot.title = element_text(face = "bold"),
    panel.grid.minor = element_blank()
  )
```

### Interpretation

**Power differences across sequencing depths.** TAP-seq consistently achieves higher overall power than perturb-seq at the same sequencing depth when cell numbers are held constant. This advantage stems from TAP-seq's higher mapping efficiency (~70% vs ~30%), which effectively provides more UMIs mapped to genes of interest per read. However, both technologies show diminishing returns at higher read depths due to UMI saturation effects. The power gap between technologies narrows at very high read depths (>80,000 reads/cell), suggesting that extreme sequencing depths may not justify TAP-seq's additional panel design costs if reads are abundant.

**Power differences across cell numbers.** When varying cell numbers at fixed sequencing depth, TAP-seq maintains its power advantage, but the relative benefit is smaller than when varying read depth. Both technologies show roughly square-root scaling of power with cell numbers (power ∝ √n), as expected from statistical theory. This suggests that for both technologies, increasing cell numbers provides consistent but diminishing returns. The similar scaling patterns indicate that the choice between technologies should primarily be driven by the sequencing depth regime you plan to operate in, rather than the number of cells you can collect.

**Practical implications.** TAP-seq is most advantageous when you have well-defined target genes and operate at moderate sequencing depths (20,000-60,000 reads/cell), where its higher mapping efficiency translates to substantial power gains. Perturb-seq remains preferable for exploratory studies where target genes are uncertain, as it provides genome-wide coverage without requiring panel design. For validation experiments with known targets at moderate depths, TAP-seq's power advantage often justifies the panel design investment. However, if you can afford very deep sequencing (>80,000 reads/cell), the technologies converge in performance, and perturb-seq's flexibility may outweigh TAP-seq's marginal power advantage.

## 2. Comparing Pre-existing Experimental Designs

Sometimes you want to compare power between experiments that have already been performed or are constrained by available resources. Let's compare four experimental designs:

### Define Competing Designs

```{r define-designs}
# Three competing designs with similar total sequencing budget
designs <- data.frame(
  Design = c("Deep", "Balanced", "Wide", "Complete"),
  Cells_per_gRNA = c(2000, 5000, 10000, 10000),
  Reads_per_Cell = c(80000, 40000, 20000, 80000),
  Description = c(
    "Fewer cells, deeper sequencing",
    "Balanced cells and depth",
    "More cells, shallow sequencing",
    "More cells, deeper sequencing"
  )
)

print(designs)
```

### Calculate Power for Each Design

Suppose we're designing a perturb-seq experiment on K562 cell line. Suppose we want to perturb 100 targeted genes with the MOI of 10, we expect a minimum fold change of 0.8 in 10% of the target-gene pairs we test, and we want to control FDR at 10%. Let's compare the overall power and overall cost for each design:

```{r compare-designs}
design_power_results <- list()

for (i in 1:nrow(designs)) {
  set.seed(123)
  power_result <- compute_power_plan(
    baseline_expression_stats = baseline_expression,
    library_parameters = library_params,
    cells_per_target = designs$Cells_per_gRNA[i],
    sequenced_reads_per_cell = designs$Reads_per_Cell[i],
    MOI = 10,
    num_targets = 100,
    control_group = "complement",
    side = "left",
    prop_non_null = 0.1,
    multiple_testing_alpha = 0.1,
    TPM_threshold = 0.1,
    minimum_fold_change = 0.8
  )

  design_power_results[[i]] <- data.frame(
    Design = designs$Design[i],
    Cells_per_gRNA = designs$Cells_per_gRNA[i],
    Num_captured_Cells = power_result$num_captured_cells,
    Reads_per_Cell = designs$Reads_per_Cell[i],
    Overall_Power = power_result$overall_power,
    Overall_Cost = perturbplan:::cost_computation(
      num_captured_cells = power_result$num_captured_cells,
      sequenced_reads_per_cell = power_result$sequenced_reads_per_cell
      )
  )
}

design_comparison <- bind_rows(design_power_results)
print(design_comparison)
```

### Visualize Power Comparison

Let's visualize the four designs in the two dimensional space of overall power and cost:

```{r power-comparison, fig.width=8, fig.height=5}
ggplot(design_comparison, aes(x = Overall_Cost, y = Overall_Power, color = Design)) +
  geom_point(size = 4) +
  labs(
    title = "Power Comparison of Pre-existing Designs",
    x = "Total Cost (USD)",
    y = "Overall Power",
    color = "Design"
  ) +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    plot.title = element_text(face = "bold"),
    panel.grid.minor = element_blank()
  )
```

### Interpretation

**Non-linear cost-power relationship.** The comparison reveals important trade-offs between overall cost and overall power across the four experimental designs. Higher cost generally leads to higher power, but the relationship is highly non-linear, with critical implications for experimental planning. 

Although the cost differences between consecutive designs are similar in magnitude, the power gains vary dramatically. The largest power improvements come from moving away from extreme designs: transitioning from "Deep" (2,000 cells, 80K reads) to "Balanced" (5,000 cells, 40K reads) or from "Wide" (10,000 cells, 20K reads) to "Complete" (10,000 cells, 80K reads) yields substantial power gains. 

**Statistical mechanisms underlying the non-linear relationship.** The different power gain from the change of experimental parameters emerges from the interaction between two distinct statistical effects. First, the saturation curve (explored in Section 3) shows that UMI counts plateau at high read depths, limiting the benefit of deeper sequencing beyond ~40,000 reads per cell for this dataset. Second, statistical power from increased cell numbers follows a square-root relationship (power scales roughly with √n), meaning doubling the number of cells provides diminishing marginal returns. 

**Resource allocation strategies for budget-constrained experiments.** If budget is limited and you can only afford incremental increases, prioritize moving away from extreme designs. For example, if currently at the "Deep" design, adding more cells (moving toward "Balanced") typically provides better return on investment than adding more sequencing depth. 

## 3. Visualizing Expression Distributions and Saturation Curves

In this section, we'll visualize the K562 perturb-seq pilot data from Gasperini et. al.(2019) in terms of baseline_expression_stats and library_params. These visualizations help understand the cases where the data from Gasperini et. al.(2019) is a good reference for your experiment and the statistical mechanisms underlying the power analyses in Sections 1 and 2.

### Gene Expression Distribution

From the baseline_expression_stats in the pilot data, let's visualize the distribution of relative expression (TPM) and the dispersion size across genes in the K562 pilot data:

```{r expression-distribution, fig.width=8, fig.height=5}
# Prepare expression data
expression_df <- baseline_expression %>%
  mutate(
    TPM = relative_expression * 1e6,
    Log10_TPM = log10(TPM + 0.1)  # Add pseudocount for log
  )

# Histogram of TPM values
ggplot(expression_df, aes(x = TPM)) +
  geom_histogram(bins = 50, fill = "steelblue", alpha = 0.7) +
  scale_x_log10(
    labels = scales::comma,
    breaks = c(0.1, 1, 10, 100, 1000, 10000)
  ) +
  labs(
    title = "Distribution of Gene Expression Levels",
    subtitle = sprintf("%d genes in baseline data", nrow(expression_df)),
    x = "Expression Level (TPM)",
    y = "Number of Genes"
  ) +
  theme_minimal() +
  theme(panel.grid.minor.x = element_line(color = "gray90", linewidth = 0.5))

# Expression vs dispersion relationship
ggplot(expression_df, aes(x = TPM, y = expression_size)) +
  geom_point(alpha = 0.3, size = 1) +
  geom_smooth(method = "loess", color = "red", linewidth = 1) +
  scale_x_log10(labels = scales::comma) +
  scale_y_log10() +
  labs(
    title = "Gene Expression vs Dispersion Parameter",
    subtitle = "Lower dispersion = higher biological variability",
    x = "Expression Level (TPM)",
    y = "Dispersion Size Parameter"
  ) +
  theme_minimal()
```

### Read saturation Curve Visualization

From the library_params in the pilot data, let's first visualize the relationship between reads per cell and UMIs per cell, and see how the experimental designs in Section 2 map onto the curve:

```{r saturation-curve, fig.width=8, fig.height=5}
# Extract library parameters
UMI_max <- library_params$UMI_per_cell
variation <- library_params$variation

# Generate saturation curve
reads_range <- seq(1000, 100000, length.out = 200)
umis_predicted <- UMI_max * (1 - exp(-reads_range / UMI_max) *
                               (1 + variation * reads_range^2 / (2 * UMI_max^2)))

saturation_df <- data.frame(
  Reads_per_Cell = reads_range,
  UMIs_per_Cell = umis_predicted,
  Saturation_Pct = (umis_predicted / UMI_max) * 100
)

# Plot saturation curve
ggplot(saturation_df, aes(x = Reads_per_Cell, y = UMIs_per_Cell)) +
  geom_line(linewidth = 1, color = "steelblue") +
  geom_hline(yintercept = UMI_max, linetype = "dashed", color = "red") +
  annotate("text", x = 80000, y = UMI_max * 1.05,
           label = sprintf("Max UMI = %d", round(UMI_max)),
           color = "red", hjust = 1) +
  # Add example design points
  geom_point(data = data.frame(
    Reads_per_Cell = c(20000, 40000, 80000),
    Design = c("Wide", "Balanced", "Deep")
  ), aes(x = Reads_per_Cell, y = UMI_max * (1 - exp(-Reads_per_Cell / UMI_max) *
                                              (1 + variation * Reads_per_Cell^2 / (2 * UMI_max^2)))),
  size = 3, color = "darkgreen") +
  geom_text(data = data.frame(
    Reads_per_Cell = c(20000, 40000, 80000),
    Design = c("Wide", "Balanced", "Deep"),
    UMI = UMI_max * (1 - exp(-c(20000, 40000, 80000) / UMI_max) *
                       (1 + variation * c(20000, 40000, 80000)^2 / (2 * UMI_max^2)))
  ), aes(x = Reads_per_Cell, y = UMI, label = Design),
  vjust = -1, color = "darkgreen") +
  scale_x_continuous(labels = scales::comma) +
  scale_y_continuous(labels = scales::comma) +
  labs(
    title = "Read-to-UMI Saturation Curve",
    subtitle = sprintf("UMI_per_cell = %d, variation = %.3f",
                      round(UMI_max), variation),
    x = "Reads per Cell",
    y = "UMIs per Cell",
    caption = "Green points show example experimental designs"
  ) +
  theme_minimal() +
  theme(panel.grid.minor = element_blank())
```

Also, we can visualize how the percentage of UMI detected (saturation) increases with read depth:

```{r saturation-percentage, fig.width=8, fig.height=6}

# Saturation percentage vs reads
ggplot(saturation_df, aes(x = Reads_per_Cell, y = Saturation_Pct)) +
  geom_line(linewidth = 1, color = "steelblue") +
  geom_hline(yintercept = 80, linetype = "dashed", color = "orange", alpha = 0.5) +
  geom_hline(yintercept = 90, linetype = "dashed", color = "red", alpha = 0.5) +
  annotate("text", x = 90000, y = 82, label = "80% saturation",
           color = "orange", hjust = 1) +
  annotate("text", x = 90000, y = 92, label = "90% saturation",
           color = "red", hjust = 1) +
  scale_x_continuous(labels = scales::comma) +
  labs(
    title = "Sequencing Saturation vs Read Depth",
    x = "Reads per Cell",
    y = "Saturation (%)"
  ) +
  theme_minimal()
```

## See Also

- `?compute_power_plan`: Prospective power analysis for experimental planning
- `?compute_power_plan_per_grid`: Grid-based power analysis
- `?library_estimation`: Library parameter estimation from QC data
- Vignette "Preprocess Reference Expression Data": Creating custom pilot data
- Vignette "Getting Started with PerturbPlan": Basic power analysis workflow
