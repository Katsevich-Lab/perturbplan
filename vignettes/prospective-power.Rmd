---
title: "Prospective Power Analysis Beyond the Web App"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Prospective Power Analysis Beyond the Web App}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "vignettes/figures/prospective-power-",
  out.width = "100%",
  fig.width = 7,
  fig.height = 5
)
```

This vignette demonstrates advanced prospective power analysis workflows that go beyond the web application's built-in functionality. We'll explore:

1. **Comparing perturb-seq and TAP-seq technologies** for the same biological question
2. **Comparing pre-existing experimental designs** instead of designing from scratch
3. **Visualizing expression distributions and saturation curves** to understand the underlying models

```{r setup}
library(perturbplan)
library(ggplot2)
library(dplyr)
library(tidyr)
```

## Load Pilot Data

First, let's load the default K562 pilot data that comes with the package:

```{r load-data}
# Load K562 pilot data
pilot_data <- get_pilot_data_from_package("K562")

# Extract components
baseline_expression <- pilot_data$baseline_expression_stats
library_params <- pilot_data$library_parameters

# View data structure
str(baseline_expression)
str(library_params)
```

## 1. Comparing Perturb-seq and TAP-seq Technologies

One common question is whether to use standard perturb-seq (whole transcriptome) or TAP-seq (targeted amplification and sequencing) for a specific experiment. TAP-seq allows deeper sequencing of a smaller set of genes, potentially improving power for targeted studies.

### Simulating TAP-seq Data

TAP-seq has two key differences from standard perturb-seq:

1. **Higher mapping efficiency** to the target gene panel (typically 60-80% vs 20-40%)
2. **Focused on a smaller gene set** (e.g., 500-2000 genes vs whole transcriptome)

Let's create TAP-seq parameters by modifying the perturb-seq baseline:

```{r tapseq-params}
# Select a subset of genes for TAP-seq panel (e.g., top 1000 by expression)
tapseq_genes <- baseline_expression %>%
  arrange(desc(relative_expression)) %>%
  head(1000) %>%
  pull(response_id)

# Create TAP-seq pilot data (subset of genes with higher mapping efficiency)
tapseq_pilot_data <- list(
  baseline_expression_stats = baseline_expression %>%
    filter(response_id %in% tapseq_genes) %>%
    mutate(relative_expression = relative_expression * (0.70 / 0.30)),  # Efficiency boost
  library_parameters = library_params
)

cat("Perturb-seq genes:", nrow(baseline_expression), "\n")
cat("TAP-seq genes:", nrow(tapseq_pilot_data$baseline_expression_stats), "\n")
cat("Efficiency boost factor: 0.70 / 0.30 =", 0.70 / 0.30, "\n")
```

### Power Comparison: Single Design Point

Let's compare power for a specific experimental design using prospective power analysis:

```{r compare-single-design}
# Define experimental parameters
cells_per_target <- 100
reads_per_cell <- 10000
minimum_fold_change <- 0.8  # Expected effect size
gRNA_variability <- 0.13    # Variability between gRNAs

# Extract fold change and expression info for perturb-seq
fc_expr_perturbseq <- extract_fc_expression_info(
  minimum_fold_change = minimum_fold_change,
  gRNA_variability = gRNA_variability,
  biological_system = "K562",
  gene_list = tapseq_genes,  # Compare same genes
  TPM_threshold = 0.1
)

# Extract fold change and expression info for TAP-seq
fc_expr_tapseq <- extract_fc_expression_info(
  minimum_fold_change = minimum_fold_change,
  gRNA_variability = gRNA_variability,
  custom_pilot_data = tapseq_pilot_data,
  gene_list = tapseq_genes,
  TPM_threshold = 0.1
)

# Calculate power for perturb-seq
power_grid_ps <- compute_power_plan_per_grid(
  cells_per_target = cells_per_target,
  reads_per_cell = reads_per_cell,
  fc_expression_df = fc_expr_perturbseq$fc_expression_df,
  library_parameters = library_params,
  control_group = "complement",
  side = "left",
  multiple_testing_alpha = 0.1,
  num_targets = 100
)

# Calculate power for TAP-seq
power_grid_ts <- compute_power_plan_per_grid(
  cells_per_target = cells_per_target,
  reads_per_cell = reads_per_cell,
  fc_expression_df = fc_expr_tapseq$fc_expression_df,
  library_parameters = tapseq_pilot_data$library_parameters,
  control_group = "complement",
  side = "left",
  multiple_testing_alpha = 0.1,
  num_targets = 100
)

# Compare results
comparison_df <- data.frame(
  Technology = c("Perturb-seq", "TAP-seq"),
  Genes_Analyzed = c(
    nrow(fc_expr_perturbseq$fc_expression_df),
    nrow(fc_expr_tapseq$fc_expression_df)
  ),
  Overall_Power = c(
    power_grid_ps$overall_power,
    power_grid_ts$overall_power
  ),
  Cells_per_Target = c(
    power_grid_ps$cells_per_target,
    power_grid_ts$cells_per_target
  )
)

print(comparison_df)
```

### Power Comparison Across Read Depths

Now let's compare how power scales with sequencing depth for both technologies:

```{r compare-read-depths, fig.width=8, fig.height=5}
# Define read depth range
read_depths <- c(5000, 10000, 15000, 20000, 30000, 40000)
comparison_results <- list()

for (i in seq_along(read_depths)) {
  reads <- read_depths[i]

  # Perturb-seq power
  power_ps <- compute_power_plan_per_grid(
    cells_per_target = cells_per_target,
    reads_per_cell = reads,
    fc_expression_df = fc_expr_perturbseq$fc_expression_df,
    library_parameters = library_params,
    control_group = "complement",
    side = "left",
    multiple_testing_alpha = 0.1,
    num_targets = 100
  )

  # TAP-seq power
  power_ts <- compute_power_plan_per_grid(
    cells_per_target = cells_per_target,
    reads_per_cell = reads,
    fc_expression_df = fc_expr_tapseq$fc_expression_df,
    library_parameters = tapseq_pilot_data$library_parameters,
    control_group = "complement",
    side = "left",
    multiple_testing_alpha = 0.1,
    num_targets = 100
  )

  comparison_results[[i]] <- data.frame(
    Reads_per_Cell = reads,
    Technology = c("Perturb-seq", "TAP-seq"),
    Overall_Power = c(power_ps$overall_power, power_ts$overall_power)
  )
}

comparison_df <- bind_rows(comparison_results)

# Plot overall power
ggplot(comparison_df, aes(x = Reads_per_Cell, y = Overall_Power,
                          color = Technology, linetype = Technology)) +
  geom_line(linewidth = 1) +
  geom_point(size = 3) +
  scale_x_continuous(labels = scales::comma) +
  scale_y_continuous(labels = scales::percent) +
  labs(
    title = "Technology Comparison: Power vs Sequencing Depth",
    subtitle = sprintf("%d cells per target, FC = %.2f, FDR = 10%%",
                      cells_per_target, minimum_fold_change),
    x = "Reads per Cell",
    y = "Overall Power",
    color = "Technology",
    linetype = "Technology"
  ) +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    plot.title = element_text(face = "bold"),
    panel.grid.minor = element_blank()
  )
```

### Cost-Benefit Analysis

Let's calculate the cost-benefit ratio assuming TAP-seq requires panel design costs:

```{r cost-benefit}
# Assume costs (adjust to your facility's pricing)
cost_per_million_reads <- 50  # dollars
tapseq_panel_design_cost <- 5000  # one-time cost

# Experimental parameters
num_targets <- 100
gRNAs_per_target <- 4
total_gRNAs <- num_targets * gRNAs_per_target

# Calculate total costs for different designs
cost_comparison <- comparison_df %>%
  mutate(
    # Total cells needed for experiment
    Total_Cells = Reads_per_Cell * cells_per_target * total_gRNAs / 10,  # MOI = 10
    # Total sequencing reads
    Total_Reads = Total_Cells * Reads_per_Cell,
    # Sequencing cost
    Sequencing_Cost = (Total_Reads / 1e6) * cost_per_million_reads,
    # Total cost (add panel design for TAP-seq)
    Total_Cost = ifelse(Technology == "TAP-seq",
                        Sequencing_Cost + tapseq_panel_design_cost,
                        Sequencing_Cost)
  )

# View cost comparison at 10K reads/cell
cost_comparison %>%
  filter(Reads_per_Cell == 10000) %>%
  select(Technology, Sequencing_Cost, Total_Cost, Overall_Power) %>%
  print()
```

### Interpretation

The comparison shows:

- **TAP-seq advantages**: Higher power per gene due to increased sequencing depth on target genes; more efficient use of sequencing budget for focused studies
- **Perturb-seq advantages**: No panel design cost; flexibility to analyze any gene post-hoc; better for exploratory studies
- **Trade-offs**: TAP-seq is cost-effective when you have well-defined target genes and want maximum power; perturb-seq is better when target genes are uncertain or for discovery-based experiments

## 2. Comparing Pre-existing Experimental Designs

Sometimes you want to compare power between experiments that have already been performed or are constrained by available resources. Let's compare three realistic experimental designs:

### Define Competing Designs

```{r define-designs}
# Three competing designs with similar total sequencing budget
designs <- data.frame(
  Design = c("Deep", "Balanced", "Wide", "Complete"),
  Cells_per_gRNA = c(2000, 5000, 10000, 10000),
  Reads_per_Cell = c(80000, 40000, 20000, 80000),
  Description = c(
    "Fewer cells, deeper sequencing",
    "Balanced cells and depth",
    "More cells, shallow sequencing",
    "More cells, deeper sequencing"
  )
)

print(designs)
```

### Calculate Power for Each Design

```{r compare-designs}
design_power_results <- list()

for (i in 1:nrow(designs)) {
  set.seed(123)
  power_result <- compute_power_plan(
    baseline_expression_stats = baseline_expression,
    library_parameters = library_params,
    cells_per_target = designs$Cells_per_gRNA[i],
    reads_per_cell = designs$Reads_per_Cell[i],
    MOI = 10, 
    num_targets = 100,
    control_group = "complement",
    side = "left",
    prop_non_null = 0.1,
    multiple_testing_alpha = 0.1,
    TPM_threshold = 0.1,
    minimum_fold_change = 0.8
  )

  design_power_results[[i]] <- data.frame(
    Design = designs$Design[i],
    Cells_per_gRNA = designs$Cells_per_gRNA[i],
    Num_captured_Cells = power_result$num_captured_cells,
    Reads_per_Cell = designs$Reads_per_Cell[i],
    Overall_Power = power_result$overall_power,
    Overall_Cost = perturbplan:::cost_computation(
      num_captured_cells = power_result$num_captured_cells,
      raw_reads_per_cell = power_result$raw_reads_per_cell
      )
  )
}

design_comparison <- bind_rows(design_power_results)
print(design_comparison)
```

### Visualize Power Comparison

Let's visualize the four designs in the two dimensional space of overall power and cost:

```{r power-comparison, fig.width=8, fig.height=5}
ggplot(design_comparison, aes(x = Overall_Cost, y = Overall_Power, color = Design)) +
  geom_point(size = 4) +
  labs(
    title = "Power Comparison of Pre-existing Designs",
    x = "Total Cost (USD)",
    y = "Overall Power",
    color = "Design"
  ) +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    plot.title = element_text(face = "bold"),
    panel.grid.minor = element_blank()
  )
```

### Interpretation

The comparison reveals important trade-offs between cell count and sequencing depth:

**Design Characteristics:**

- **Deep design**: Fewer cells with deeper sequencing provides higher UMI counts per cell, beneficial for detecting changes in low-expression genes but limited by smaller sample sizes
- **Balanced design**: Moderate cells and sequencing depth offers a compromise, balancing detection sensitivity with statistical power from cell numbers
- **Wide design**: More cells with shallower sequencing increases statistical power through larger sample sizes but may miss effects on low-expression genes
- **Complete design**: Maximum cells and depth represents the gold standard but at significantly higher cost

**Key Insights:**

1. **Power vs Cost**: The "Complete" design achieves the highest power but at a substantially higher cost than other designs. The cost increase may not be justified if the "Balanced" or "Wide" design already achieves acceptable power (e.g., >80%).

2. **Diminishing Returns**: Moving from "Wide" to "Complete" shows diminishing returns in power relative to cost increase, suggesting that moderate designs often provide the best value.

3. **Expression-Dependent Effects**:
   - Low-expression genes benefit more from the "Deep" design due to higher UMI counts reducing sampling noise
   - High-expression genes benefit more from the "Wide" design since additional cells provide more statistical power than marginal UMI increases

4. **Experimental Constraints**: Real experiments often face constraints (e.g., limited cells from rare cell types, fixed sequencing budget). This comparison helps identify which constraint matters most for your specific application.

**Practical Recommendations:**

- If most target genes are lowly expressed (< 10 TPM): favor deeper sequencing designs
- If target genes span a wide expression range: favor balanced or wide designs to ensure adequate power across all genes
- If discovery is the goal: favor wide designs to maximize the number of cells and improve rare cell type detection
- If validating specific hypotheses: consider deep designs to maximize sensitivity for target genes

The optimal choice depends on your biological question, expression range of target genes, and budget constraints. Use the saturation curves (Section 3) to identify the point of diminishing returns for sequencing depth in your pilot data.

## 3. Visualizing Expression Distributions and Saturation Curves

Understanding the underlying statistical models helps interpret power analysis results.

### Gene Expression Distribution

Let's visualize the distribution of gene expression levels in the pilot data:

```{r expression-distribution, fig.width=8, fig.height=6}
# Prepare expression data
expression_df <- baseline_expression %>%
  mutate(
    TPM = relative_expression * 1e6,
    Log10_TPM = log10(TPM + 0.1)  # Add pseudocount for log
  )

# Histogram of TPM values
ggplot(expression_df, aes(x = TPM)) +
  geom_histogram(bins = 50, fill = "steelblue", alpha = 0.7) +
  scale_x_log10(labels = scales::comma) +
  labs(
    title = "Distribution of Gene Expression Levels",
    subtitle = sprintf("%d genes in baseline data", nrow(expression_df)),
    x = "Expression Level (TPM)",
    y = "Number of Genes"
  ) +
  theme_minimal() +
  theme(panel.grid.minor = element_blank())

# Expression vs dispersion relationship
ggplot(expression_df, aes(x = TPM, y = expression_size)) +
  geom_point(alpha = 0.3, size = 1) +
  geom_smooth(method = "loess", color = "red", linewidth = 1) +
  scale_x_log10(labels = scales::comma) +
  scale_y_log10() +
  labs(
    title = "Gene Expression vs Dispersion Parameter",
    subtitle = "Lower dispersion = higher biological variability",
    x = "Expression Level (TPM)",
    y = "Dispersion Size Parameter"
  ) +
  theme_minimal()
```

### Saturation Curve Visualization

The saturation curve relates reads per cell to UMIs per cell. Let's visualize this relationship:

```{r saturation-curve, fig.width=8, fig.height=6}
# Extract library parameters
UMI_max <- library_params$UMI_per_cell
variation <- library_params$variation

# Generate saturation curve
reads_range <- seq(1000, 100000, length.out = 200)
umis_predicted <- UMI_max * (1 - exp(-reads_range / UMI_max) *
                               (1 + variation * reads_range^2 / (2 * UMI_max^2)))

saturation_df <- data.frame(
  Reads_per_Cell = reads_range,
  UMIs_per_Cell = umis_predicted,
  Saturation_Pct = (umis_predicted / UMI_max) * 100
)

# Plot saturation curve
ggplot(saturation_df, aes(x = Reads_per_Cell, y = UMIs_per_Cell)) +
  geom_line(linewidth = 1, color = "steelblue") +
  geom_hline(yintercept = UMI_max, linetype = "dashed", color = "red") +
  annotate("text", x = 80000, y = UMI_max * 1.05,
           label = sprintf("Max UMI = %d", round(UMI_max)),
           color = "red", hjust = 1) +
  # Add example design points
  geom_point(data = data.frame(
    Reads_per_Cell = c(20000, 40000, 80000),
    Design = c("Wide", "Balanced", "Deep")
  ), aes(x = Reads_per_Cell, y = UMI_max * (1 - exp(-Reads_per_Cell / UMI_max) *
                                              (1 + variation * Reads_per_Cell^2 / (2 * UMI_max^2)))),
  size = 3, color = "darkgreen") +
  geom_text(data = data.frame(
    Reads_per_Cell = c(20000, 40000, 80000),
    Design = c("Wide", "Balanced", "Deep"),
    UMI = UMI_max * (1 - exp(-c(20000, 40000, 80000) / UMI_max) *
                       (1 + variation * c(20000, 40000, 80000)^2 / (2 * UMI_max^2)))
  ), aes(x = Reads_per_Cell, y = UMI, label = Design),
  vjust = -1, color = "darkgreen") +
  scale_x_continuous(labels = scales::comma) +
  scale_y_continuous(labels = scales::comma) +
  labs(
    title = "Read-to-UMI Saturation Curve",
    subtitle = sprintf("UMI_per_cell = %d, variation = %.3f",
                      round(UMI_max), variation),
    x = "Reads per Cell",
    y = "UMIs per Cell",
    caption = "Green points show example experimental designs"
  ) +
  theme_minimal() +
  theme(panel.grid.minor = element_blank())

# Saturation percentage vs reads
ggplot(saturation_df, aes(x = Reads_per_Cell, y = Saturation_Pct)) +
  geom_line(linewidth = 1, color = "steelblue") +
  geom_hline(yintercept = 80, linetype = "dashed", color = "orange", alpha = 0.5) +
  geom_hline(yintercept = 90, linetype = "dashed", color = "red", alpha = 0.5) +
  annotate("text", x = 90000, y = 82, label = "80% saturation",
           color = "orange", hjust = 1) +
  annotate("text", x = 90000, y = 92, label = "90% saturation",
           color = "red", hjust = 1) +
  scale_x_continuous(labels = scales::comma) +
  labs(
    title = "Sequencing Saturation vs Read Depth",
    x = "Reads per Cell",
    y = "Saturation (%)"
  ) +
  theme_minimal()
```

### Marginal Utility of Additional Reads

As sequencing depth increases, the marginal benefit decreases due to saturation. Let's visualize this:

```{r marginal-utility, fig.width=8, fig.height=5}
# Calculate marginal UMIs per additional 1000 reads
saturation_df <- saturation_df %>%
  mutate(
    Marginal_UMI = c(NA, diff(UMIs_per_Cell) / (diff(Reads_per_Cell) / 1000))
  )

ggplot(saturation_df, aes(x = Reads_per_Cell, y = Marginal_UMI)) +
  geom_line(linewidth = 1, color = "steelblue") +
  geom_hline(yintercept = 0.5, linetype = "dashed", color = "red", alpha = 0.5) +
  annotate("text", x = 80000, y = 0.55,
           label = "< 0.5 UMI per 1000 reads: diminishing returns",
           color = "red", hjust = 1) +
  scale_x_continuous(labels = scales::comma) +
  labs(
    title = "Marginal Utility of Additional Sequencing",
    subtitle = "Additional UMIs gained per 1000 extra reads",
    x = "Reads per Cell",
    y = "Marginal UMIs per 1000 Reads"
  ) +
  theme_minimal() +
  theme(panel.grid.minor = element_blank())
```

### Simulating Expression for Individual Cells

Let's simulate what gene expression looks like for individual cells at different sequencing depths:

```{r simulate-cells, fig.width=8, fig.height=6}
# Select a few example genes across expression range
example_genes <- baseline_expression %>%
  arrange(relative_expression) %>%
  slice(c(100, 500, 1000, 2000)) %>%
  mutate(Gene_Label = paste0("Gene ", row_number(),
                            " (", round(relative_expression * 1e6, 1), " TPM)"))

# Simulate cells at different read depths
simulate_expression <- function(gene_data, n_cells, reads_per_cell, library_params) {
  # Calculate UMIs per cell from reads
  UMI_max <- library_params$UMI_per_cell
  variation <- library_params$variation
  umi_per_cell <- UMI_max * (1 - exp(-reads_per_cell / UMI_max) *
                               (1 + variation * reads_per_cell^2 / (2 * UMI_max^2)))

  # Simulate gene expression using negative binomial
  # mean = library_size * relative_expression
  # size = expression_size
  gene_expression <- rnbinom(
    n = n_cells,
    mu = umi_per_cell * gene_data$relative_expression,
    size = gene_data$expression_size
  )

  return(gene_expression)
}

# Simulate for different read depths (matching Section 2 designs)
set.seed(123)
simulation_results <- list()

for (i in 1:nrow(example_genes)) {
  for (reads in c(20000, 40000, 80000)) {
    gene_counts <- simulate_expression(
      example_genes[i, ],
      n_cells = 500,
      reads_per_cell = reads,
      library_params = library_params
    )

    simulation_results[[length(simulation_results) + 1]] <- data.frame(
      Gene = example_genes$Gene_Label[i],
      Reads_per_Cell = reads,
      Expression = gene_counts
    )
  }
}

simulation_df <- bind_rows(simulation_results)

# Plot distributions
ggplot(simulation_df, aes(x = Expression, fill = factor(Reads_per_Cell))) +
  geom_histogram(alpha = 0.6, bins = 30, position = "identity") +
  facet_wrap(~Gene, scales = "free", ncol = 2) +
  scale_fill_brewer(palette = "Set2",
                    labels = c("20K (Wide)", "40K (Balanced)", "80K (Deep)")) +
  labs(
    title = "Simulated Cell-to-Cell Expression Distributions",
    subtitle = "500 cells per condition across three experimental designs",
    x = "UMI Counts",
    y = "Number of Cells",
    fill = "Design"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")
```

### Interpretation

The visualizations reveal key insights about the underlying statistical models:

**Expression Distribution:**
- Most genes have low-to-medium expression (< 100 TPM), with a heavy right tail of highly expressed genes
- The dispersion parameter (expression_size) tends to be lower for lowly expressed genes, indicating higher biological variability
- This heterogeneity means different genes benefit from different experimental designs

**Saturation Effects:**
- The saturation curve shows diminishing returns beyond ~40,000 reads per cell for this dataset
- At 20,000 reads (Wide design): moderate saturation, cost-effective for most applications
- At 40,000 reads (Balanced design): approaching diminishing returns, suitable for comprehensive studies
- At 80,000 reads (Deep design): significant saturation, only justified for detecting subtle changes in low-expression genes

**Marginal Utility:**
- Each additional 1,000 reads provides progressively fewer additional UMIs
- Beyond 40,000-50,000 reads per cell, marginal utility drops below 0.5 UMIs per 1,000 reads
- This explains why the "Complete" design in Section 2 shows diminishing returns relative to its cost

**Cell-Level Variation:**
- The simulated distributions show that:
  - Low-expression genes (< 10 TPM) have high coefficient of variation, making them harder to detect without deeper sequencing
  - High-expression genes show more consistent expression across cells, benefiting more from additional cells than additional depth
  - The three design points (20K, 40K, 80K reads/cell) show how sequencing depth affects detection resolution

**Connection to Section 2 Designs:**
- **Wide design (20K reads)**: Sits in the steep part of the saturation curve, maximizing cells while maintaining reasonable UMI counts
- **Balanced design (40K reads)**: Reaches the inflection point where marginal returns start to decline noticeably
- **Deep design (80K reads)**: Well into the saturation plateau, justified only for specific applications requiring maximum sensitivity for low-expression targets

## Practical Recommendations

Based on these analyses:

1. **Technology choice**:
   - Use TAP-seq when you have a well-defined gene panel and want maximum power per gene
   - Use perturb-seq for exploratory studies or when target genes are uncertain

2. **Design optimization**:
   - Balance cells vs depth based on your expression range of interest
   - Consider saturation curves when deciding sequencing depth
   - Low-expression genes benefit more from deeper sequencing
   - High-expression genes benefit more from additional cells

3. **Cost considerations**:
   - Calculate cost per expected discovery, not just total cost
   - Account for fixed costs (panel design) vs variable costs (sequencing)
   - Consider pilot experiments to refine parameters before large studies

4. **Model validation**:
   - Visualize your pilot data's expression distribution and saturation curve
   - Check that model assumptions (NB distribution, saturation curve) fit your data
   - If fit is poor, consider collecting additional pilot data

## Session Information

```{r session-info}
sessionInfo()
```

## See Also

- `?compute_power_plan`: Prospective power analysis for experimental planning
- `?compute_power_plan_per_grid`: Grid-based power analysis
- `?library_estimation`: Library parameter estimation from QC data
- Vignette "Preprocess Reference Expression Data": Creating custom pilot data
- Vignette "Getting Started with PerturbPlan": Basic power analysis workflow
