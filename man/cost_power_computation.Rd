% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/power_plan.R
\name{cost_power_computation}
\alias{cost_power_computation}
\title{Cost-Power Optimization for Perturb-seq Experimental Design}
\usage{
cost_power_computation(
  minimizing_variable = "TPM_threshold",
  fixed_variable = list(minimum_fold_change = 0.8),
  MOI = 10,
  num_targets = 100,
  non_targeting_gRNAs = 10,
  gRNAs_per_target = 4,
  gRNA_variability = 0.13,
  assay = "perturb-seq",
  control_group = "complement",
  side = "left",
  multiple_testing_alpha = 0.05,
  prop_non_null = 0.1,
  baseline_expression_stats,
  library_parameters,
  grid_size = 20,
  power_target = 0.8,
  power_precision = 0.01,
  min_power = 0.05,
  max_power = 0.95,
  cost_precision = 0.9,
  cost_per_captured_cell = 0.086,
  cost_per_million_reads = 0.374,
  cost_constraint = NULL,
  mapping_efficiency = 0.72
)
}
\arguments{
\item{minimizing_variable}{Character. The parameter to vary during analysis.
Options: "TPM_threshold" or "minimum_fold_change". Default: "TPM_threshold".}

\item{fixed_variable}{List. Fixed values for other analysis parameters. Can include:
\itemize{
\item \code{minimum_fold_change}: Fixed fold change threshold (when varying TPM_threshold)
\item \code{TPM_threshold}: Fixed TPM threshold (when varying minimum_fold_change)
\item \code{cells_per_target}: Fixed cells per target (otherwise uses "varying")
\item \code{reads_per_cell}: Fixed reads per cell (otherwise uses "varying")
}}

\item{MOI}{Numeric. Multiplicity of infection (default: 10).}

\item{num_targets}{Integer. Number of targets (default: 100).}

\item{non_targeting_gRNAs}{Integer. Number of non-targeting gRNAs (default: 10).}

\item{gRNAs_per_target}{Integer. Number of gRNAs per target (default: 4).}

\item{gRNA_variability}{Numeric. gRNA variability parameter (default: 0.13).}

\item{assay}{String. Assay type: "perturb-seq" or "TAP-seq" (default: "perturb-seq").}

\item{control_group}{Character. Control group type: "complement" or "non_targeting" (default: "complement").}

\item{side}{Character. Test side: "left", "right", or "both" (default: "left").}

\item{multiple_testing_alpha}{Numeric. Multiple testing significance level (default: 0.05).}

\item{prop_non_null}{Numeric. Proportion of non-null hypotheses (default: 0.1).}

\item{baseline_expression_stats}{Data frame. Baseline expression statistics with columns:
\code{response_id}, \code{relative_expression}, \code{expression_size}.}

\item{library_parameters}{List. Library parameters containing \code{UMI_per_cell} and \code{variation}.}

\item{grid_size}{Integer. Grid size for parameter search (default: 20).}

\item{power_target}{Numeric. Target statistical power (default: 0.8).}

\item{power_precision}{Numeric. Acceptable precision around power target (default: 0.01).}

\item{min_power}{Numeric. Minimum power threshold for grid search (default: 0.05).}

\item{max_power}{Numeric. Maximum power threshold for grid search (default: 0.95).}

\item{cost_precision}{Numeric. Cost utilization factor (default: 0.9).
Filters designs with total cost \\le cost_precision × cost_constraint.}

\item{cost_per_captured_cell}{Numeric. Cost per captured cell in dollars (default: 0.086).}

\item{cost_per_million_reads}{Numeric. Cost per million sequencing reads in dollars (default: 0.374).}

\item{cost_constraint}{Numeric. Maximum budget constraint in dollars (default: NULL).
Set to \code{NULL} to disable cost constraints.}

\item{mapping_efficiency}{Numeric. Sequencing mapping efficiency (default: 0.72).}
}
\value{
Data frame with power analysis results including:
\itemize{
\item Analysis parameters (TPM_threshold, minimum_fold_change, etc.)
\item Experimental design (cells_per_target, num_captured_cells, raw_reads_per_cell)
\item Power metrics (overall_power)
\item Cost breakdown (library_cost, sequencing_cost, total_cost) - when cost_constraint is specified
\item Power threshold indicator (meets_threshold) - when cost_constraint is NULL
}

Data frame with power analysis results including:
\itemize{
\item Analysis parameters (TPM_threshold, minimum_fold_change, etc.)
\item Experimental design (cells_per_target, num_captured_cells, raw_reads_per_cell)
\item Power metrics (overall_power)
\item Cost breakdown (library_cost, sequencing_cost, total_cost)
}
}
\description{
Performs cost-constrained optimization to find the minimal parameter value that achieves
target statistical power within a specified budget for perturb-seq experiments.
}
\details{
This function implements a two-stage optimization algorithm:

\strong{Stage 1: Coarse Grid Search}
\enumerate{
\item Creates parameter grid for the minimizing variable:
\itemize{
\item TPM_threshold: 20 log-spaced values from 1 to 1000 TPM
\item minimum_fold_change: 20 values based on test side (left: 0.01-1.0, right: 1.0-10.0, both: combined)
}
\item Runs power analysis across experimental design space
\item Applies dual filtering:
\itemize{
\item Power filter: \code{power_target ± power_precision}
      \item Cost filter: \code{total_cost \\le budget_precision × cost_constraint}
    }
\item Identifies minimum parameter value meeting both constraints
}

\strong{Stage 2: Fine Grid Search}
\enumerate{
\item Re-runs power analysis with optimal parameter and higher resolution (100 grid points)
\item Combines coarse and fine search results for comprehensive output
}

\strong{Cost Model:}
\deqn{Total Cost = Library Cost + Sequencing Cost}
\deqn{Library Cost = cost\_per\_captured\_cell \times num\_captured\_cells}
\deqn{Sequencing Cost = cost\_per\_million\_reads \times raw\_reads\_per\_cell \times num\_captured\_cells / 10^6}

This function performs comprehensive power analysis by:
\enumerate{
\item Setting up parameter grids based on the minimizing variable
\item Computing power across experimental design space
\item Calculating costs for each design
\item Applying validation checks via \code{check_power_results()}
}

\strong{Cost Model:}

Total cost is calculated as the sum of library preparation and sequencing costs:

\code{Total Cost = Library Cost + Sequencing Cost}

Where:
\itemize{
\item \code{Library Cost = cost_per_captured_cell * num_captured_cells}
\item \code{Sequencing Cost = cost_per_million_reads * (raw_reads_per_cell * num_captured_cells) / 1,000,000}
}

Parameter grid generation:
\itemize{
\item \code{TPM_threshold}: Uses quantiles of baseline expression (10th to 99th percentile)
\item \code{minimum_fold_change}: Uses ranges based on test side (left: 0.5-0.9, right: 1-10, both: combined)
}
}
\examples{
# Load pilot data
pilot_data <- get_pilot_data_from_package("K562")

# Optimize TPM threshold with fixed fold change
result1 <- cost_power_computation(
  minimizing_variable = "TPM_threshold",
  fixed_variable = list(minimum_fold_change = 0.8),
  baseline_expression_stats = pilot_data$baseline_expression_stats,
  library_parameters = pilot_data$library_parameters,
  power_target = 0.8,
  cost_constraint = 15000,
  cost_precision = 0.9
)

print("TPM threshold optimization results:")
print(paste("Number of designs analyzed:", nrow(result1)))
print(paste("TPM threshold range:", round(min(result1$TPM_threshold)), "-", round(max(result1$TPM_threshold))))
print(paste("Power range:", round(min(result1$overall_power), 3), "-", round(max(result1$overall_power), 3)))
print(paste("Cost range: $", round(min(result1$total_cost)), "-", "$", round(max(result1$total_cost)), sep=""))

# Optimize fold change with fixed TPM threshold
result2 <- cost_power_computation(
  minimizing_variable = "minimum_fold_change",
  fixed_variable = list(TPM_threshold = 10),
  baseline_expression_stats = pilot_data$baseline_expression_stats,
  library_parameters = pilot_data$library_parameters,
  power_target = 0.9,
  cost_constraint = NULL  # No cost constraint
)

print("\nFold change optimization results:")
print(paste("Number of designs analyzed:", nrow(result2)))
print(paste("Fold change range:", round(min(result2$minimum_fold_change), 2), "-", round(max(result2$minimum_fold_change), 2)))
print(paste("Power range:", round(min(result2$overall_power), 3), "-", round(max(result2$overall_power), 3)))
head(result2[c("minimum_fold_change", "cells_per_target", "overall_power")])

# Load pilot data
pilot_data <- get_pilot_data_from_package("K562")

# Compute power across TPM_threshold range
result1 <- cost_power_computation(
  minimizing_variable = "TPM_threshold",
  fixed_variable = list(minimum_fold_change = 0.8),
  baseline_expression_stats = pilot_data$baseline_expression_stats,
  library_parameters = pilot_data$library_parameters,
  power_target = 0.8,
  cost_constraint = 15000
)

print("TPM threshold analysis:")
print(paste("Analyzed", nrow(result1), "experimental designs"))
print(summary(result1$overall_power))

# Compute power across fold change range
result2 <- cost_power_computation(
  minimizing_variable = "minimum_fold_change",
  fixed_variable = list(TPM_threshold = 50),
  baseline_expression_stats = pilot_data$baseline_expression_stats,
  library_parameters = pilot_data$library_parameters,
  power_target = 0.8,
  cost_constraint = NULL
)

print("Fold change analysis:")
print(paste("Fold change effects from", round(min(result2$minimum_fold_change), 2), "to", round(max(result2$minimum_fold_change), 2)))

# Optimize cost across all experimental designs
result3 <- cost_power_computation(
  minimizing_variable = "cost",
  fixed_variable = list(TPM_threshold = 50, minimum_fold_change = 0.8),
  baseline_expression_stats = pilot_data$baseline_expression_stats,
  library_parameters = pilot_data$library_parameters,
  power_target = 0.8,
  cost_constraint = NULL
)

print("Cost optimization results:")
print(paste("Min cost: $", round(min(result3$total_cost)), ", Max cost: $", round(max(result3$total_cost)), sep=""))
print(paste("Optimal design achieves", round(max(result3$overall_power), 3), "power"))

# Optimize cells per target with fixed detection parameters
result4 <- cost_power_computation(
  minimizing_variable = "cells_per_target",
  fixed_variable = list(TPM_threshold = 50, minimum_fold_change = 0.8),
  baseline_expression_stats = pilot_data$baseline_expression_stats,
  library_parameters = pilot_data$library_parameters,
  power_target = 0.8,
  cost_constraint = 10000
)

print("Cell optimization results:")
print(paste("Cell range:", round(min(result4$cells_per_target)), "to", round(max(result4$cells_per_target)), "per target"))
print(paste("All designs under budget of $10,000 with power ~", round(result4$overall_power[1], 3)))

}
\seealso{
\code{\link{compute_power_plan_full_grid}} for the underlying power analysis
\code{\link{find_optimal_cost_design}} for cost optimization
Cost-Constrained Power Analysis for Perturb-seq Experiments

Performs comprehensive power analysis across experimental design space with optional
cost constraints for perturb-seq experiments. Computes power across parameter grids
and applies filtering based on power targets and budget constraints.
}
