% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/power_plan.R
\name{compute_power_plan_per_grid}
\alias{compute_power_plan_per_grid}
\title{Compute power analysis for experimental design grid}
\usage{
compute_power_plan_per_grid(
  cells_per_target,
  reads_per_cell,
  fc_expression_df,
  library_parameters,
  grid_size = 10,
  min_power_threshold = 0.01,
  max_power_threshold = 0.8,
  MOI = 10,
  num_targets = 100,
  gRNAs_per_target = 4,
  non_targeting_gRNAs = 10,
  control_group = "complement",
  multiple_testing_alpha = 0.05,
  side = "left",
  prop_non_null = 0.1,
  mapping_efficiency = 0.72,
  cell_recovery_rate = 0.5,
  QC_rate = 1
)
}
\arguments{
\item{cells_per_target}{Numeric or character. Number of cells per target or "varying" for auto-generated grid.}

\item{reads_per_cell}{Numeric or character. Reads per cell or "varying" for auto-generated grid.}

\item{fc_expression_df}{Data frame with fold change and expression information.}

\item{library_parameters}{List containing UMI_per_cell and variation parameters.}

\item{grid_size}{Integer. Number of points in each dimension of the grid (default: 10).}

\item{min_power_threshold}{Numeric. Minimum power threshold for cell range determination (default: 0.01).}

\item{max_power_threshold}{Numeric. Maximum power threshold for cell range determination (default: 0.8).}

\item{MOI}{Numeric. Multiplicity of infection for cell allocation calculations (default: 10).}

\item{num_targets}{Integer. Number of targets for cell allocation calculations (default: 100).}

\item{gRNAs_per_target}{Integer. Number of gRNAs per target (default: 4).}

\item{non_targeting_gRNAs}{Integer. Number of non-targeting gRNAs (default: 10).}

\item{control_group}{String. Control group type: "complement" or "nt_cells" (default: "complement").}

\item{multiple_testing_alpha}{Numeric. Alpha level for multiple testing (default: 0.05).}

\item{side}{String. Test sidedness: "left", "right", or "both" (default: "left").}

\item{prop_non_null}{Numeric. Proportion of non-null hypotheses (default: 0.1).}

\item{mapping_efficiency}{Numeric. Mapping efficiency for raw reads to usable reads (default: 0.72).}

\item{cell_recovery_rate}{Numeric. Rate of cell recovery from loading to capture (default: 0.5).}

\item{QC_rate}{Numeric. Quality control rate from captured to usable cells (default: 1.0).}
}
\value{
Data frame with columns:
\describe{
\item{cells_per_target}{Numeric. Number of treatment cells per target}
\item{reads_per_cell}{Numeric. Sequencing reads per cell}
\item{library_size}{Numeric. Effective library size (UMIs)}
\item{overall_power}{Numeric. Statistical power for this experimental design}
\item{num_usable_cells}{Numeric. Number of usable cells after QC}
\item{num_captured_cells}{Numeric. Number of captured cells}
\item{num_loaded_cells}{Numeric. Number of loaded cells}
\item{raw_reads_per_cell}{Numeric. Raw reads per cell before mapping}
}
}
\description{
Simplified version of identify_cell_read_range that returns a clean dataframe
with experimental design combinations and their corresponding power values.
}
\details{
This function simplifies the experimental design process by:
\enumerate{
\item Determining parameter ranges based on "varying" vs fixed inputs:
- If cells_per_target = "varying": Uses identify_cell_range_cpp() to determine optimal cell range
- If reads_per_cell = "varying": Uses identify_reads_range_cpp() to determine optimal read range
- If parameters are numeric: Uses the specified fixed values
\item Creating logarithmically-spaced grids dynamically:
- Both varying: grid_size × grid_size combinations
- One varying: grid_size × 1 (or 1 × grid_size) combinations
- Both fixed: 1 × 1 single combination
\item Computing power for all parameter combinations
\item Returning a clean dataframe ready for analysis
}
}
