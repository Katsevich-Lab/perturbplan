# Suppress R CMD check notes for NSE (non-standard evaluation) variables
utils::globalVariables(c("Perturb_tpm", "Tap_tpm", "in_band", "expression_status"))

#' Aggregate Expression and QC Data from Multiple SRR-Level Cell Ranger Outputs
#'
#' @description
#' Aggregates Cell Ranger outputs from multiple sequencing runs (SRRs) into a single
#' data structure containing gene expression matrices, UMI-level molecule information,
#' and naive mapping efficiency estimates. This is Step 1 of the pilot data preprocessing
#' workflow for PerturbPlan power analysis.
#'
#' @param path_to_top_level_output Character. Path to the top-level directory
#'   containing Cell Ranger run-level subdirectories. Each subdirectory should contain
#'   Cell Ranger output in the standard structure with \code{outs/} folders.
#' @param path_to_run_level_output Optional character vector. Names of specific run-level
#'   directories to process (not full paths). Should match the basename of folders
#'   inside \code{path_to_top_level_output}. If NULL, all subdirectories are processed.
#'   Unmatched entries will trigger a warning.
#' @param h5_rough Logical. If TRUE (default), extracts UMI-level molecule information
#'   from first SRR only for speed. If FALSE, combines UMI-level molecule information
#'   from all SRRs (slower but more comprehensive).
#' @param skip_mapping_efficiency Logical. If TRUE, skips estimation of mapping efficiency.
#'   If FALSE (default), calculates naive mapping efficiency. Set to TRUE when
#'   \code{metrics_summary.csv} is unavailable or lacks "Number of Reads" column.
#'
#' @return A list with three elements:
#' \describe{
#'   \item{response_matrix}{Sparse gene-by-cell expression matrix (genes as rows,
#'     cells as columns) with row and column names. Contains only genes common across
#'     all processed SRR runs, combined across all runs.}
#'   \item{read_umi_table}{Data frame with UMI-level molecule information, including columns:
#'     \itemize{
#'       \item \code{num_reads}: Number of reads supporting this UMI-cell combination
#'       \item \code{UMI_id}: UMI index
#'       \item \code{cell_id}: Cell barcode
#'       \item \code{response_id}: Gene identifier (e.g., Ensembl ID)
#'       \item \code{srr_idx}: SRR run identifier
#'     }}
#'   \item{mapping_efficiency}{Numeric value between 0 and 1 representing the proportion
#'     of reads that are confidently mapped to the transcriptome and assigned to a true
#'     cell barcode (i.e., a cell barcode that appears in the filtered expression matrix)
#'     among all raw reads recorded in \code{metrics_summary.csv} if
#'     \code{skip_mapping_efficiency = FALSE}, or NULL if \code{skip_mapping_efficiency = TRUE}.}
#' }
#'
#' @details
#' ## Input Requirements
#'
#' Your data should be organized with Cell Ranger output directories under a top-level folder:
#' \preformatted{
#' path_to_top_level_output/
#' ├── SRR_run_1/
#' │   ├── outs/
#' │   │   ├── filtered_feature_bc_matrix/
#' │   │   │   ├── barcodes.tsv.gz
#' │   │   │   ├── features.tsv.gz
#' │   │   │   └── matrix.mtx.gz
#' │   │   ├── molecule_info.h5
#' │   │   ├── filtered_feature_bc_matrix.h5
#' │   │   └── metrics_summary.csv
#' ├── SRR_run_2/
#' │   └── ...
#' └── SRR_run_3/
#'     └── ...
#' }
#'
#' ## Processing Steps
#'
#' The function performs the following operations:
#' \enumerate{
#'   \item Lists all SRR directories under the given top-level folder
#'   \item Optionally filters to a subset of run-level names
#'   \item Reads gene expression matrices using \code{\link{obtain_qc_response_data}}
#'   \item Identifies and retains only genes shared across all SRRs
#'   \item Reads UMI-level molecule information using \code{\link{obtain_qc_read_umi_table}}
#'   \item Calculates naive mapping efficiency using \code{\link{obtain_mapping_efficiency}}
#' }
#'
#' ## Important Notes
#'
#' \itemize{
#'   \item SRR directories should be generated by a recent version of \strong{Cell Ranger count}
#'     (not Cell Ranger multi) configured for the perturbation (CRISPR or Perturb-seq) workflow
#'     using standard output format
#'   \item \strong{Cell Ranger multi is not currently supported} because: (1) its output directory
#'     structure places files under \code{outs/per_sample_outs/\{sample_id\}/count/} instead of
#'     directly under \code{outs/}, and (2) its \code{metrics_summary.csv} uses a row-based format
#'     with "Library Type" and "Metric Name" columns, while Cell Ranger count uses a column-based
#'     format where metric names are column headers
#'   \item In some cases, \code{filtered_feature_bc_matrix/} may need to be produced by
#'     unzipping \code{filtered_feature_bc_matrix.tar.gz}
#'   \item For mapping efficiency calculation, \code{metrics_summary.csv} must include
#'     a column named "Number of Reads" (Cell Ranger count format)
#'   \item When \code{h5_rough = FALSE}, multiple mapping efficiencies are computed and
#'     the median value is returned
#' }
#'
#'
#'
#' @importFrom stats median
#' @importFrom dplyr mutate between
#' @examples
#' # Point to directory containing example Cell Ranger outputs
#' extdata_path <- system.file("extdata", package = "perturbplan")
#'
#' # Aggregate data from all SRR runs
#' raw_data <- reference_data_preprocessing_10x(
#'   path_to_top_level_output = extdata_path,
#'   path_to_run_level_output = "cellranger_tiny",  # Only read subfolder cellranger_tiny
#'   h5_rough = TRUE,  # Use first SRR for QC data (faster)
#'   skip_mapping_efficiency = FALSE  # Estimate mapping efficiency
#' )
#'
#' # Inspect structure
#' str(raw_data)
#'
#' # Access components
#' head(raw_data$read_umi_table)
#' dim(raw_data$response_matrix)
#'
#' @seealso
#' \code{\link{reference_data_processing}} for Step 2 of the preprocessing workflow.
#'
#' \code{\link{obtain_qc_response_data}}, \code{\link{obtain_qc_read_umi_table}},
#' and \code{\link{obtain_mapping_efficiency}} for details on data extraction.
#'
#' See the vignette "Preprocess Reference Expression data for Web App" for the
#' complete preprocessing workflow: \code{vignette("preprocess-reference", package = "perturbplan")}
#' @export
reference_data_preprocessing_10x <- function(path_to_top_level_output,
                                             path_to_run_level_output = NULL,
                                             h5_rough = TRUE,
                                             skip_mapping_efficiency = FALSE
                                             ) {
  run_dirs <- list.dirs(path_to_top_level_output, recursive = FALSE, full.names = TRUE)
  run_dir_names <- basename(run_dirs)

  if (!is.null(path_to_run_level_output)) {
    missing_dirs <- setdiff(path_to_run_level_output, run_dir_names)
    if (length(missing_dirs) > 0) {
      warning("The following directories were not found in the run directories: ",
              paste(missing_dirs, collapse = ", "))
    }
    run_dirs <- run_dirs[run_dir_names %in% path_to_run_level_output]
    run_dir_names <- basename(run_dirs)  # update names after filtering
  }

  if (length(run_dirs) == 0) {
    stop("No valid run directories found.")
  }

  # Read response matrices
  mats <- lapply(run_dirs, perturbplan::obtain_qc_response_data)
  gene_lists <- lapply(mats, rownames)
  common_genes <- Reduce(intersect, gene_lists)

  if (length(common_genes) == 0) {
    stop("No common genes found across SRRs.")
  }

  # Warn if some genes are missing
  missing_genes <- lapply(mats, function(mat) setdiff(rownames(mat), common_genes))
  if (any(sapply(missing_genes, length) > 0)) {
    warning("Some genes are missing in some matrices: ",
            paste(sapply(missing_genes, function(x) paste(x, collapse = ", ")), collapse = "; "))
  }

  # Subset matrices
  mats <- lapply(mats, function(mat) mat[common_genes, , drop = FALSE])
  response_matrix <- do.call(cbind, mats)

  mapping_efficiency <- NULL
  # Read h5 data to get read umi table and mapping efficiency
  if (h5_rough) {
    read_umi_table <- perturbplan::obtain_qc_read_umi_table(run_dirs[1]) |>
      dplyr::mutate(srr_idx = run_dir_names[1])
    mapping_efficiency <- obtain_mapping_efficiency(read_umi_table,run_dirs[1])
  } else {
    read_umi_table <- list()
    for (i in seq_along(run_dirs)) {
      current <- perturbplan::obtain_qc_read_umi_table(run_dirs[i]) |>
        dplyr::mutate(srr_idx = run_dir_names[i])
      mapping_efficiency[i] <- obtain_mapping_efficiency(current,run_dirs[i])
      read_umi_table[[i]] <- current
    }
    read_umi_table <- dplyr::bind_rows(read_umi_table)

    if(length(mapping_efficiency)>1){
      message("Multiple SRR runs detected. Using median mapping efficiency across runs: ",
              paste(round(mapping_efficiency,3), collapse = ", "))
    }
    if (!skip_mapping_efficiency){
      mapping_efficiency <- median(mapping_efficiency,na.rm=TRUE)
    } else {
      mapping_efficiency <- NULL
    }
  }

  return(list(
    response_matrix = response_matrix,
    read_umi_table = read_umi_table,
    mapping_efficiency = mapping_efficiency
  ))
}




#' Extract Statistical Parameters from Pilot Data for Power Analysis
#'
#' @description
#' Fits statistical models to extract gene-level expression parameters, library saturation
#' parameters, and adjusted mapping efficiency required by PerturbPlan for power analysis.
#' This is Step 2 of the pilot data preprocessing workflow. Outputs are compatible with
#' built-in pilot data examples and the PerturbPlan Shiny application.
#'
#' @param response_matrix Matrix or NULL. Gene-by-cell expression matrix, typically from
#'   \code{\link{reference_data_preprocessing_10x}}. Required unless \code{h5_only = TRUE}.
#' @param read_umi_table Data frame. UMI-level molecule information from
#'   \code{\link{obtain_qc_read_umi_table}}, typically obtained via
#'   \code{\link{reference_data_preprocessing_10x}}.
#' @param mapping_efficiency Numeric or NULL. Naive mapping efficiency estimate from
#'   \code{\link{obtain_mapping_efficiency}}. Will be adjusted based on \code{gene_list}
#'   if provided.
#' @param gene_list Optional character vector of gene IDs (e.g., Ensembl IDs) to restrict
#'   analysis to specific genes. Used for TAP-seq experimental design. If NULL, all genes
#'   are used (suitable for perturb-seq).
#' @param TPM_thres Numeric. Threshold (in TPM) for filtering low-expression genes in
#'   gene expression model. Default: 0.1.
#' @param downsample_ratio Numeric. Proportion of downsampling in library saturation model
#'   fitting. Default: 0.7.
#' @param D2_rough Numeric. Rough prior value for library variation parameter. Typically
#'   higher in TAP-seq experiments (e.g., 0.8) than perturb-seq experiments (0.3).
#'   Default: 0.3.
#' @param h5_only Logical. If TRUE, skips baseline expression step to save time. Useful
#'   when tuning hyperparameters for library model fitting. Default: FALSE.
#' @param n_threads Integer or NULL. Number of parallel processing threads. If NULL,
#'   uses single-threaded execution. Default: NULL.
#'
#' @return A list containing:
#' \describe{
#'   \item{baseline_expression_stats}{Data frame with columns:
#'     \itemize{
#'       \item \code{response_id}: Ensembl gene identifier
#'       \item \code{relative_expression}: Estimated relative expression proportions,
#'         normalized to sum to 1 across all genes of interest
#'       \item \code{expression_size}: Estimated dispersion (size) parameter representing
#'         gene-specific expression variability
#'     }}
#'   \item{library_parameters}{List with:
#'     \itemize{
#'       \item \code{UMI_per_cell}: Estimated maximum UMI count per cell at saturation
#'       \item \code{variation}: Estimated PCR amplification variation parameter (0 to 1)
#'     }}
#'   \item{mapping_efficiency}{Numeric. Adjusted mapping efficiency accounting for
#'     fraction of reads mapped to genes of interest.}
#' }
#'
#' @details
#' ## Statistical Models
#'
#' \strong{Gene Expression Model (Negative Binomial):}
#'
#' For each gene, the function fits a negative binomial (NB) model to characterize the
#' distribution of gene expression levels across cells:
#'
#' \code{gene_expression ~ NB(mean = library_size * relative_expression, expression_size = expression_size)}
#'
#' where:
#' \itemize{
#'   \item \code{gene_expression}: Number of observed UMIs for the gene in each cell (data)
#'   \item \code{library_size}: Total UMI count per cell (data)
#'   \item \code{relative_expression}: Relative expression level of the gene (fitted parameter)
#'   \item \code{expression_size}: Dispersion parameter; small values indicate high biological
#'     variability (fitted parameter)
#' }
#'
#' \strong{Sequencing Saturation Model (S-M Curve):}
#'
#' The function fits a saturation (S-M) curve that relates mapped reads per cell to
#' observed UMIs per cell:
#'
#' \code{UMI = total_UMIs * (1 - exp(-reads/total_UMIs) * (1 + variation * reads^2/(2*total_UMIs^2)))}
#'
#' where:
#' \itemize{
#'   \item \code{reads}: Number of mapped reads per cell (data)
#'   \item \code{UMI}: Number of observed UMIs per cell (data)
#'   \item \code{total_UMIs} (UMI_per_cell): Maximum UMI per cell parameter at saturation
#'     (fitted parameter)
#'   \item \code{variation}: Variation parameter characterizing PCR amplification bias,
#'     between 0 and 1 (fitted parameter)
#' }
#'
#' ## Processing Steps
#'
#' The function executes these steps:
#' \enumerate{
#'   \item If \code{gene_list} provided: adjusts mapping efficiency and filters genes
#'   \item Fits negative binomial model using \code{\link{obtain_expression_information}}
#'     to estimate gene-level expression parameters
#'   \item Fits saturation model using \code{\link{library_computation}} to estimate
#'     library parameters
#'   \item Returns structured output compatible with power analysis functions
#' }
#'
#' ## Use Cases
#'
#' \itemize{
#'   \item \strong{Perturb-seq}: Use all genes (\code{gene_list = NULL}), default
#'     \code{D2_rough = 0.3}
#'   \item \strong{TAP-seq}: Provide targeted gene list, higher \code{D2_rough}
#'     (e.g., 0.8), set \code{TPM_thres = 0}
#' }
#'
#' @seealso
#' \code{\link{reference_data_preprocessing_10x}} for Step 1 of the preprocessing workflow.
#'
#' \code{\link{obtain_expression_information}} for NB model fitting details.
#'
#' \code{\link{library_computation}} for S-M curve fitting details.
#'
#' See the vignette "Preprocess Reference Expression data for Web App" for the
#' complete preprocessing workflow: \code{vignette("preprocess-reference", package = "perturbplan")}
#'
#'
#' @importFrom stats median
#' @importFrom dplyr mutate between
#' @examples
#' # Set seed for reproducibility
#' set.seed(123)
#'
#' # First, get aggregated raw data using reference_data_preprocessing_10x
#' extdata_path <- system.file("extdata", package = "perturbplan")
#' raw_data <- reference_data_preprocessing_10x(
#'   path_to_top_level_output = extdata_path,
#'   path_to_run_level_output = "cellranger_tiny",
#'   h5_rough = TRUE
#' )
#'
#' # Example 1: Process for perturb-seq experimental design (all genes)
#' pilot_data_perturbseq <- reference_data_processing(
#'   response_matrix = raw_data$response_matrix,
#'   read_umi_table = raw_data$read_umi_table,
#'   mapping_efficiency = raw_data$mapping_efficiency,
#'   gene_list = NULL,     # Use all genes
#'   TPM_thres = 0.1,      # Default expression threshold for filtering
#'   downsample_ratio = 0.6,  # Downsampling for sequencing
#'   D2_rough = 0.4,       # Prior for variation parameter
#'   h5_only = FALSE,      # Fit expression model
#'   n_threads = NULL      # No parallel processing
#' )
#'
#' # Inspect structure
#' str(pilot_data_perturbseq)
#'
#' # Example 2: Process for TAP-seq experimental design (targeted genes only)
#' gene_list <- c("ENSG00000241860", "ENSG00000238009", "ENSG00000239945")
#' pilot_data_tapseq <- reference_data_processing(
#'   response_matrix = raw_data$response_matrix,
#'   read_umi_table = raw_data$read_umi_table,
#'   mapping_efficiency = raw_data$mapping_efficiency,
#'   gene_list = gene_list, # Restrict to specific genes
#'   TPM_thres = 0          # No expression threshold for filtering
#' )
#'
#' # Inspect structure
#' str(pilot_data_tapseq)
#'
#' @export
reference_data_processing <- function(response_matrix = NULL, read_umi_table, mapping_efficiency = NULL,
                                      gene_list=NULL, TPM_thres = 0.1, downsample_ratio = 0.7, D2_rough = 0.3,
                                      h5_only = FALSE, n_threads = NULL
                                        ) {

  message("Starting pilot data preprocessing @ ", Sys.time())
  if (!h5_only){
  message("Step 1: Computing gene expression information...")
  if (!is.null(gene_list)) {
    # check what proportion of reads are mapped to the gene list with respect to the response_matrix
    if (is.null(response_matrix)) {
      stop("response_matrix cannot be NULL when gene_list is provided and h5_only is FALSE.")
    }
    # Filter response_matrix to only include genes in gene_list
    response_matrix <- response_matrix[rownames(response_matrix) %in% gene_list, , drop = FALSE]
    if (nrow(response_matrix) == 0) {
      stop("No genes from gene_list found in response_matrix.")
    }
  }
  baseline_expression_df <- obtain_expression_information(
    response_matrix = response_matrix,
    TPM_thres = TPM_thres,  # No filtering during preprocessing
    n_threads = n_threads
  )
  } else {
    message("Skipping Step 1 as h5_only is TRUE")
    baseline_expression_df <- NULL
  }

  # Adjust mapping efficiency if gene_list is provided
  if (!is.null(gene_list) & !is.null(mapping_efficiency)) {
    # Adjust mapping efficiency based on gene list
    lst <- read_umi_table$response_id %in% gene_list
    mapping_efficiency <- mean(lst)* mapping_efficiency
  }
  
  message("Step 2: Estimating library parameters...")
  if (!is.null(gene_list)){
  # Filter read_umi_table to only include molecules from the gene list
  read_umi_table <- read_umi_table |>
    dplyr::filter(response_id %in% gene_list)
  }
  library_params <- library_estimation(
    QC_data = read_umi_table,
    downsample_ratio = downsample_ratio,
    D2_rough = D2_rough
  )
  
  # Construct the final output structure with simplified baseline expression
  result <- list(
    baseline_expression_stats = baseline_expression_df,
    library_parameters = library_params,  # Already has UMI_per_cell and variation
    mapping_efficiency = mapping_efficiency
  )

  message("Completed pilot data preprocessing @ ", Sys.time())
  message("Processed ", nrow(baseline_expression_df), " genes")
  message("Library parameters: UMI_per_cell = ", round(library_params$UMI_per_cell),
          ", variation = ", signif(library_params$variation, 3))
  message("Mapping efficiency = ", ifelse(is.null(mapping_efficiency), "NA", round(mapping_efficiency, 3)))

  return(result)
}
