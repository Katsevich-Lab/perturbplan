# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

rejection_computation_cpp <- function(mean_list, sd_list, side, cutoff) {
    .Call(`_perturbplan_rejection_computation_cpp`, mean_list, sd_list, side, cutoff)
}

compute_FDP_posthoc <- function(mean_list, sd_list, side, cutoff, QC_prob) {
    .Call(`_perturbplan_compute_FDP_posthoc`, mean_list, sd_list, side, cutoff, QC_prob)
}

compute_BH_posthoc <- function(mean_list, sd_list, side, multiple_testing_alpha, QC_prob) {
    .Call(`_perturbplan_compute_BH_posthoc`, mean_list, sd_list, side, multiple_testing_alpha, QC_prob)
}

compute_FDP_plan <- function(mean_list, sd_list, side, cutoff, prop_non_null) {
    .Call(`_perturbplan_compute_FDP_plan`, mean_list, sd_list, side, cutoff, prop_non_null)
}

compute_BH_plan <- function(mean_list, sd_list, side, multiple_testing_alpha, prop_non_null) {
    .Call(`_perturbplan_compute_BH_plan`, mean_list, sd_list, side, multiple_testing_alpha, prop_non_null)
}

compute_QC_fixed_es_cpp <- function(fold_change, expression_mean, expression_size, num_cntrl_cells, num_cells, n_nonzero_trt_thresh = 7L, n_nonzero_cntrl_thresh = 7L) {
    .Call(`_perturbplan_compute_QC_fixed_es_cpp`, fold_change, expression_mean, expression_size, num_cntrl_cells, num_cells, n_nonzero_trt_thresh, n_nonzero_cntrl_thresh)
}

compute_distribution_teststat_fixed_es_cpp <- function(fold_change, expression_mean, expression_size, num_trt_cells, num_cntrl_cells, num_cells) {
    .Call(`_perturbplan_compute_distribution_teststat_fixed_es_cpp`, fold_change, expression_mean, expression_size, num_trt_cells, num_cntrl_cells, num_cells)
}

#' Compute Test Statistic Distribution for Random Effect Sizes
#' 
#' @description
#' Computes the asymptotic mean and standard deviation of the score test statistic
#' for random effect sizes in perturb-seq experiments. This function handles the
#' case where fold changes vary randomly across perturbations, using the average
#' fold change and its second moment.
#' 
#' @param num_trt_cell Numeric. Number of treatment cells
#' @param num_cntrl_cell Numeric. Number of control cells  
#' @param expression_mean Numeric. Mean baseline expression level
#' @param expression_size Numeric. Size parameter for negative binomial distribution
#' @param avg_fold_change Numeric. Average fold change across perturbations
#' @param avg_fold_change_sq Numeric. Average of squared fold changes (second moment)
#' 
#' @return A list containing:
#' \describe{
#'   \item{mean}{Numeric. Asymptotic mean of the test statistic}
#'   \item{sd}{Numeric. Asymptotic standard deviation of the test statistic}
#' }
#' 
#' @details
#' This function computes the asymptotic distribution of the score test statistic
#' under the assumption of random effect sizes. The key difference from fixed
#' effect sizes is that it accounts for variability in fold changes using the
#' second moment (avg_fold_change_sq).
#' 
#' The computation follows these steps:
#' \enumerate{
#'   \item Compute treatment/control cell proportions
#'   \item Calculate treatment, control, and pooled expression means
#'   \item Compute pooled variance using negative binomial variance formula
#'   \item Calculate denominator squared for the test statistic
#'   \item Compute control group variance
#'   \item Compute treatment group variance (incorporating fold change variability)
#'   \item Calculate final asymptotic mean and standard deviation
#' }
#'
#' @examples
#' # Single gene test statistic distribution calculation
#' result <- compute_distribution_teststat_random_es_cpp(
#'   num_trt_cell = 400,
#'   num_cntrl_cell = 600,
#'   expression_mean = 15.5,  # UMIs per cell for this gene
#'   expression_size = 1.2,   # Dispersion parameter
#'   avg_fold_change = 0.8,   # Average fold change across gRNAs
#'   avg_fold_change_sq = 0.67  # Second moment of fold changes
#' )
#'
#' print(paste("Test statistic mean:", round(result$mean, 3)))
#' print(paste("Test statistic SD:", round(result$sd, 3)))
#'
#' @seealso \code{\link{compute_monte_carlo_teststat_cpp}} for batch processing multiple genes
#' @export
compute_distribution_teststat_random_es_cpp <- function(num_trt_cell, num_cntrl_cell, expression_mean, expression_size, avg_fold_change, avg_fold_change_sq) {
    .Call(`_perturbplan_compute_distribution_teststat_random_es_cpp`, num_trt_cell, num_cntrl_cell, expression_mean, expression_size, avg_fold_change, avg_fold_change_sq)
}

#' Identify optimal cell count range based on power thresholds (C++)
#'
#' @description
#' Determines minimum and maximum cell counts for power analysis using binary search.
#' Uses a cross-search strategy to guarantee logical ordering (min_cells <= max_cells):
#' finds min_cells with best-case reads and max_cells with worst-case reads.
#'
#' @param min_reads_per_cell Numeric. Minimum reads per cell from library size range
#' @param max_reads_per_cell Numeric. Maximum reads per cell from library size range
#' @param fc_expression_df DataFrame with fold change and expression info
#' @param UMI_per_cell Numeric. Maximum UMI per cell parameter from S-M curve
#' @param variation Numeric. Variation parameter from S-M curve
#' @param MOI Numeric. Multiplicity of infection (default 10)
#' @param num_targets Integer. Number of targets (default 100)
#' @param gRNAs_per_target Integer. gRNAs per target (default 4)
#' @param non_targeting_gRNAs Integer. Non-targeting gRNAs (default 10)
#' @param control_group String. Control group type ("complement" or "nt_cells", default "complement")
#' @param multiple_testing_alpha Numeric. FDR target level (default 0.05)
#' @param side String. Test sidedness ("left", "right", "both", default "left")
#' @param prop_non_null Numeric. Proportion of non-null hypotheses (default 0.1)
#' @param min_power_threshold Numeric. Minimum power threshold for min cells (default 0.01)
#' @param max_power_threshold Numeric. Target power threshold for max cells (default 0.8)
#' @param cell_lower_bound Numeric. Lower bound for total cell search (default 100)
#' @param cell_upper_bound Numeric. Upper bound for total cell search (default 1e7)
#'
#' @return List with min_cells, max_cells, and achieved power values
#'
#' @details
#' This function performs two binary searches using a cross-search strategy:
#' \itemize{
#'   \item Find minimum cells: Where power >= min_power_threshold using max_reads_per_cell (best-case)
#'   \item Find maximum cells: Where power >= max_power_threshold using min_reads_per_cell (worst-case)
#' }
#' 
#' This cross-search strategy ensures min_cells <= max_cells and provides robust
#' experimental design ranges from minimally acceptable to well-powered studies.
#'
#' @examples
#' # Extract fold change and expression information
#' fc_expr_data <- extract_fc_expression_info(
#'   minimum_fold_change = 0.8,
#'   gRNA_variability = 0.13,
#'   biological_system = "K562",
#'   B = 200
#' )
#' 
#' # Get library parameters and reads range
#' pilot_data <- get_pilot_data_from_package("K562")
#' library_params <- pilot_data$library_parameters
#' reads_range <- identify_reads_range_cpp(
#'   UMI_per_cell = library_params$UMI_per_cell,
#'   variation = library_params$variation
#' )
#' 
#' # Find optimal cell count range
#' cell_range <- identify_cell_range_cpp(
#'   min_reads_per_cell = reads_range$min_reads_per_cell,
#'   max_reads_per_cell = reads_range$max_reads_per_cell,
#'   fc_expression_df = fc_expr_data,
#'   UMI_per_cell = library_params$UMI_per_cell,
#'   variation = library_params$variation,
#'   MOI = 10,
#'   num_targets = 100,
#'   side = "left"
#' )
#' 
#' # View results
#' print(cell_range)
#' 
#' @export
identify_cell_range_cpp <- function(min_reads_per_cell, max_reads_per_cell, fc_expression_df, UMI_per_cell, variation, MOI = 10.0, num_targets = 100L, gRNAs_per_target = 4L, non_targeting_gRNAs = 10L, control_group = "complement", multiple_testing_alpha = 0.05, side = "left", prop_non_null = 0.1, min_power_threshold = 0.01, max_power_threshold = 0.8, cell_lower_bound = 100.0, cell_upper_bound = 1e7) {
    .Call(`_perturbplan_identify_cell_range_cpp`, min_reads_per_cell, max_reads_per_cell, fc_expression_df, UMI_per_cell, variation, MOI, num_targets, gRNAs_per_target, non_targeting_gRNAs, control_group, multiple_testing_alpha, side, prop_non_null, min_power_threshold, max_power_threshold, cell_lower_bound, cell_upper_bound)
}

#' Compute effective library size from read depth using UMI saturation curve (C++)
#'
#' @description
#' C++ implementation of the saturation-magnitude (S-M) curve that relates 
#' sequencing reads to unique UMI counts, accounting for PCR amplification 
#' variability and UMI saturation.
#'
#' @param reads_per_cell Numeric vector. Total reads per cell.
#' @param UMI_per_cell Numeric. Maximum UMI per cell parameter from S-M curve fit.
#' @param variation Numeric. Variation parameter characterizing PCR bias from S-M curve fit.
#'
#' @return Numeric vector. Effective library size in UMIs for each read depth.
#'
#' @details
#' This C++ implementation provides significant performance improvements over the R version
#' for large-scale power analysis computations. The S-M curve formula:
#' \deqn{effective\_UMI = UMI\_per\_cell \times (1 - exp(-reads\_per\_cell / UMI\_per\_cell) \times (1 + variation \times reads\_per\_cell^2 / (2 \times UMI\_per\_cell^2)))}
#'
#' @seealso \code{\link{fit_read_UMI_curve}} for R version
#' @keywords internal
fit_read_UMI_curve_cpp <- function(reads_per_cell, UMI_per_cell, variation) {
    .Call(`_perturbplan_fit_read_UMI_curve_cpp`, reads_per_cell, UMI_per_cell, variation)
}

#' Identify optimal reads per cell range for power analysis grid (C++)
#'
#' @description
#' C++ implementation that determines the minimum and maximum reads per cell values 
#' for power analysis grid generation using binary search on the S-M curve.
#' Uses saturation-based thresholds (10% and 80%) instead of platform-specific minimums.
#'
#' @param experimental_platform String. Experimental platform identifier (kept for compatibility, not used).
#' @param UMI_per_cell Numeric. Maximum UMI per cell parameter.
#' @param variation Numeric. Variation parameter for S-M curve.
#'
#' @return List with min_reads_per_cell and max_reads_per_cell elements.
#'
#' @details
#' This C++ implementation uses efficient binary search to find the reads per cell
#' range for power analysis. Uses saturation-based thresholds:
#' - Minimum reads: 10% UMI saturation (dynamic based on UMI_per_cell)
#' - Maximum reads: 80% UMI saturation (diminishing returns beyond this point)
#'
#' @seealso \code{\link{identify_library_size_range}} for R version
#' @keywords internal
identify_library_size_range_cpp <- function(experimental_platform, UMI_per_cell, variation) {
    .Call(`_perturbplan_identify_library_size_range_cpp`, experimental_platform, UMI_per_cell, variation)
}

#' Generate reads per cell grid using S-M curve analysis (C++)
#'
#' @description
#' Convenience function that combines range identification with grid generation
#' for power analysis heatmaps.
#'
#' @param experimental_platform String. Experimental platform identifier.
#' @param UMI_per_cell Numeric. Maximum UMI per cell parameter.
#' @param variation Numeric. Variation parameter for S-M curve.
#' @param grid_size Integer. Number of points in the grid (default: 10).
#'
#' @return NumericVector. Sequence of reads per cell values for grid.
#'
#' @keywords internal
generate_reads_grid_cpp <- function(experimental_platform, UMI_per_cell, variation, grid_size = 10L) {
    .Call(`_perturbplan_generate_reads_grid_cpp`, experimental_platform, UMI_per_cell, variation, grid_size)
}

#' Identify optimal reads per cell range (streamlined version)
#'
#' @description
#' Streamlined C++ implementation that determines the minimum and maximum reads per cell values 
#' for power analysis grid generation using binary search on the S-M curve.
#' Uses saturation-based thresholds (10% and 80%) with a clean API.
#'
#' @param UMI_per_cell Numeric. Maximum UMI per cell parameter.
#' @param variation Numeric. Variation parameter for S-M curve.
#'
#' @return List with min_reads_per_cell and max_reads_per_cell elements.
#'
#' @details
#' This streamlined version removes the unused experimental_platform parameter.
#' Uses efficient binary search to find the reads per cell range for power analysis:
#' - Minimum reads: 10% UMI saturation (dynamic based on UMI_per_cell)
#' - Maximum reads: 80% UMI saturation (diminishing returns beyond this point)
#'
#' @examples
#' # Get library parameters from pilot data
#' pilot_data <- get_pilot_data_from_package("K562")
#' library_params <- pilot_data$library_parameters
#' 
#' # Find optimal reads per cell range for power analysis
#' reads_range <- identify_reads_range_cpp(
#'   UMI_per_cell = library_params$UMI_per_cell,
#'   variation = library_params$variation
#' )
#' 
#' # View the range
#' print(reads_range)
#' print(paste("Range:", reads_range$min_reads_per_cell, "to", reads_range$max_reads_per_cell))
#' 
#' @export
identify_reads_range_cpp <- function(UMI_per_cell, variation) {
    .Call(`_perturbplan_identify_reads_range_cpp`, UMI_per_cell, variation)
}

#' Generate reads per cell grid (streamlined version)
#'
#' @description
#' Streamlined convenience function that combines range identification with grid generation
#' for power analysis heatmaps.
#'
#' @param UMI_per_cell Numeric. Maximum UMI per cell parameter.
#' @param variation Numeric. Variation parameter for S-M curve.
#' @param grid_size Integer. Number of points in the grid (default: 10).
#'
#' @return NumericVector. Sequence of reads per cell values for grid.
#'
#' @keywords internal
generate_reads_grid_streamlined_cpp <- function(UMI_per_cell, variation, grid_size = 10L) {
    .Call(`_perturbplan_generate_reads_grid_streamlined_cpp`, UMI_per_cell, variation, grid_size)
}

#' Compute Monte Carlo test statistics for power analysis with random effect sizes
#'
#' @description
#' This C++ function efficiently computes test statistic distributions using Monte Carlo
#' integration for power analysis with random gRNA effect sizes. It processes multiple
#' gene-perturbation pairs simultaneously for improved performance.
#'
#' @param fc_expression_df Data frame with fold change and expression information including:
#'   avg_fold_change, avg_fold_change_sq, relative_expression, expression_size
#' @param library_size Numeric. Effective library size (UMIs per cell)
#' @param num_trt_cells Integer. Number of treatment cells
#' @param num_cntrl_cells Integer. Number of control cells
#'
#' @return List with elements:
#' \describe{
#'   \item{means}{Numeric vector of mean test statistics for each gene}
#'   \item{sds}{Numeric vector of standard deviations of test statistics for each gene}
#' }
#'
#' @details
#' This function performs Monte Carlo integration to compute test statistic distributions
#' when gRNA effect sizes are random variables. It handles the random effect size framework
#' where each gene-perturbation pair has a distribution of potential effects.
#'
#' @examples
#' # Prepare fold change and expression data
#' fc_expr_data <- extract_fc_expression_info(
#'   minimum_fold_change = 0.8,
#'   gRNA_variability = 0.13,
#'   biological_system = "K562",
#'   B = 50
#' )$fc_expression_df
#'
#' # Calculate effective library size
#' pilot_data <- get_pilot_data_from_package("K562")
#' library_size <- fit_read_UMI_curve(
#'   reads_per_cell = 25000,
#'   UMI_per_cell = pilot_data$library_parameters$UMI_per_cell,
#'   variation = pilot_data$library_parameters$variation
#' )
#'
#' # Compute test statistic distributions
#' mc_result <- compute_monte_carlo_teststat_cpp(
#'   fc_expression_df = fc_expr_data,
#'   library_size = library_size,
#'   num_trt_cells = 400,
#'   num_cntrl_cells = 600
#' )
#'
#' # Examine results
#' head(data.frame(means = mc_result$means, sds = mc_result$sds))
#'
#' @seealso \code{\link{compute_distribution_teststat_random_es_cpp}} for single gene calculations
#' @export
compute_monte_carlo_teststat_cpp <- function(fc_expression_df, library_size, num_trt_cells, num_cntrl_cells) {
    .Call(`_perturbplan_compute_monte_carlo_teststat_cpp`, fc_expression_df, library_size, num_trt_cells, num_cntrl_cells)
}

#' Compute overall power for power analysis (C++)
#'
#' @description
#' C++ implementation of compute_power_plan_overall that provides significant 
#' performance improvements for power analysis computations. Uses random effect sizes
#' format with avg_fold_change and avg_fold_change_sq columns.
#'
#' @param fc_expression_df DataFrame with fold change and expression info. Must contain:
#'   \itemize{
#'     \item relative_expression: Relative expression levels
#'     \item expression_size: Size parameters for negative binomial distribution
#'     \item avg_fold_change: Average fold change across perturbations
#'     \item avg_fold_change_sq: Average of squared fold changes (second moment)
#'   }
#' @param library_size Numeric. Effective library size
#' @param num_trt_cells Numeric. Number of treatment cells  
#' @param num_cntrl_cells Numeric. Number of control cells
#' @param multiple_testing_alpha Numeric. FDR target level (default 0.05)
#' @param multiple_testing_method String. Method ("BH" only supported)
#' @param side String. Test sidedness ("left", "right", "both")
#' @param prop_non_null Numeric. Proportion of non-null hypotheses (default 0.1)
#' @param return_full_results Logical. Return full results or just overall power
#'
#' @return Numeric overall power (if return_full_results=FALSE) or List with full results
#'
#' @details
#' This C++ implementation uses optimized C++ functions for random effect sizes:
#' \itemize{
#'   \item compute_monte_carlo_teststat_cpp(): Monte Carlo test statistics for random effect sizes
#'   \item compute_BH_plan(): Benjamini-Hochberg significance cutoff
#'   \item rejection_computation_cpp(): Power calculations
#' }
#' 
#' The function provides identical results to the R version while offering
#' significant performance improvements by eliminating R function call overhead.
#'
#' @seealso \code{\link{compute_power_plan_overall}} for R version
#' @keywords internal
compute_power_plan_overall_cpp <- function(fc_expression_df, library_size, num_trt_cells, num_cntrl_cells, multiple_testing_alpha = 0.05, multiple_testing_method = "BH", side = "left", prop_non_null = 0.1, return_full_results = FALSE) {
    .Call(`_perturbplan_compute_power_plan_overall_cpp`, fc_expression_df, library_size, num_trt_cells, num_cntrl_cells, multiple_testing_alpha, multiple_testing_method, side, prop_non_null, return_full_results)
}

#' Compute power for a single experimental design point (C++)
#'
#' @description
#' Lightweight C++ function that computes power for a single cell count and 
#' read depth combination. Optimized for use in binary search algorithms for 
#' cell range determination.
#'
#' @param num_cells Numeric. Total number of cells in the experiment
#' @param reads_per_cell Numeric. Sequencing reads per cell
#' @param fc_expression_df DataFrame with fold change and expression info
#' @param UMI_per_cell Numeric. Maximum UMI per cell parameter from S-M curve
#' @param variation Numeric. Variation parameter from S-M curve
#' @param MOI Numeric. Multiplicity of infection (default 10)
#' @param num_targets Integer. Number of targets (default 100)
#' @param gRNAs_per_target Integer. gRNAs per target (default 4)
#' @param non_targeting_gRNAs Integer. Non-targeting gRNAs (default 10)
#' @param control_group String. Control group type ("complement" or "nt_cells", default "complement")
#' @param multiple_testing_alpha Numeric. FDR target level (default 0.05)
#' @param side String. Test sidedness ("left", "right", "both", default "left")
#' @param prop_non_null Numeric. Proportion of non-null hypotheses (default 0.1)
#'
#' @return Numeric. Overall power for the specified experimental design point
#'
#' @details
#' This function efficiently computes power for a single experimental condition by:
#' \itemize{
#'   \item Converting read depth to library size using S-M curve (fit_read_UMI_curve_cpp)
#'   \item Calculating treatment and control cell counts based on experimental design
#'   \item Computing overall power using compute_power_plan_overall_cpp
#' }
#' 
#' The function is designed for use in binary search algorithms that determine
#' optimal cell count ranges based on power thresholds.
#'
#' @examples
#' # Extract fold change and expression information
#' fc_expr_data <- extract_fc_expression_info(
#'   minimum_fold_change = 0.8,
#'   gRNA_variability = 0.13,
#'   biological_system = "K562",
#'   B = 100
#' )$fc_expression_df
#'
#' # Get library parameters
#' pilot_data <- get_pilot_data_from_package("K562")
#' library_params <- pilot_data$library_parameters
#'
#' # Calculate power for specific experimental conditions
#' power_result <- compute_single_power_cpp(
#'   num_cells = 5000,
#'   reads_per_cell = 25000,
#'   fc_expression_df = fc_expr_data,
#'   UMI_per_cell = library_params$UMI_per_cell,
#'   variation = library_params$variation,
#'   MOI = 10,
#'   num_targets = 100,
#'   side = "left"
#' )
#'
#' print(paste("Power:", round(power_result, 3)))
#'
#' @seealso \code{\link{compute_power_plan_overall_cpp}} for full power analysis
#' @export
compute_single_power_cpp <- function(num_cells, reads_per_cell, fc_expression_df, UMI_per_cell, variation, MOI = 10.0, num_targets = 100L, gRNAs_per_target = 4L, non_targeting_gRNAs = 10L, control_group = "complement", multiple_testing_alpha = 0.05, side = "left", prop_non_null = 0.1) {
    .Call(`_perturbplan_compute_single_power_cpp`, num_cells, reads_per_cell, fc_expression_df, UMI_per_cell, variation, MOI, num_targets, gRNAs_per_target, non_targeting_gRNAs, control_group, multiple_testing_alpha, side, prop_non_null)
}

theta_batch_cpp <- function(Y, library_size, rel_expr, rough = FALSE, n_threads = 0L) {
    .Call(`_perturbplan_theta_batch_cpp`, Y, library_size, rel_expr, rough, n_threads)
}

