# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

rejection_computation_cpp <- function(mean_list, sd_list, side, cutoff) {
    .Call(`_perturbplan_rejection_computation_cpp`, mean_list, sd_list, side, cutoff)
}

compute_FDP_posthoc <- function(mean_list, sd_list, side, cutoff, QC_prob) {
    .Call(`_perturbplan_compute_FDP_posthoc`, mean_list, sd_list, side, cutoff, QC_prob)
}

compute_BH_posthoc <- function(mean_list, sd_list, side, multiple_testing_alpha, QC_prob) {
    .Call(`_perturbplan_compute_BH_posthoc`, mean_list, sd_list, side, multiple_testing_alpha, QC_prob)
}

compute_FDP_plan <- function(mean_list, sd_list, side, cutoff, prop_non_null) {
    .Call(`_perturbplan_compute_FDP_plan`, mean_list, sd_list, side, cutoff, prop_non_null)
}

compute_BH_plan <- function(mean_list, sd_list, side, multiple_testing_alpha, prop_non_null) {
    .Call(`_perturbplan_compute_BH_plan`, mean_list, sd_list, side, multiple_testing_alpha, prop_non_null)
}

compute_QC_fixed_es_cpp <- function(fold_change, expression_mean, expression_size, num_cntrl_cells, num_cells, n_nonzero_trt_thresh = 7L, n_nonzero_cntrl_thresh = 7L) {
    .Call(`_perturbplan_compute_QC_fixed_es_cpp`, fold_change, expression_mean, expression_size, num_cntrl_cells, num_cells, n_nonzero_trt_thresh, n_nonzero_cntrl_thresh)
}

compute_distribution_teststat_fixed_es_cpp <- function(fold_change, expression_mean, expression_size, num_trt_cells, num_cntrl_cells, num_cells) {
    .Call(`_perturbplan_compute_distribution_teststat_fixed_es_cpp`, fold_change, expression_mean, expression_size, num_trt_cells, num_cntrl_cells, num_cells)
}

#' Identify optimal cell count range based on power thresholds (C++)
#'
#' @description
#' Determines minimum and maximum cell counts for power analysis using binary search.
#' Uses minimum reads per cell to find where power first reaches 1%, and maximum reads 
#' per cell to find where power reaches 80%.
#'
#' @param min_reads_per_cell Numeric. Minimum reads per cell from library size range
#' @param max_reads_per_cell Numeric. Maximum reads per cell from library size range
#' @param fc_expression_df DataFrame with fold change and expression info
#' @param UMI_per_cell Numeric. Maximum UMI per cell parameter from S-M curve
#' @param variation Numeric. Variation parameter from S-M curve
#' @param MOI Numeric. Multiplicity of infection (default 10)
#' @param num_targets Integer. Number of targets (default 100)
#' @param gRNAs_per_target Integer. gRNAs per target (default 4)
#' @param non_targeting_gRNAs Integer. Non-targeting gRNAs (default 10)
#' @param control_group String. Control group type ("complement" or "nt_cells", default "complement")
#' @param multiple_testing_alpha Numeric. FDR target level (default 0.05)
#' @param side String. Test sidedness ("left", "right", "both", default "left")
#' @param prop_non_null Numeric. Proportion of non-null hypotheses (default 0.1)
#' @param min_power_threshold Numeric. Minimum power threshold for min cells (default 0.01)
#' @param max_power_threshold Numeric. Target power threshold for max cells (default 0.8)
#' @param cell_lower_bound Numeric. Lower bound for treatment cell search (default 100)
#' @param cell_upper_bound Numeric. Upper bound for treatment cell search (default 1e5)
#'
#' @return List with min_cells, max_cells, and achieved power values
#'
#' @details
#' This function performs two binary searches:
#' \itemize{
#'   \item Find minimum cells: Where power ≥ 1% using minimum reads per cell
#'   \item Find maximum cells: Where power ≥ 80% using maximum reads per cell
#' }
#' 
#' The resulting cell range spans from barely useful (1% power) to highly powered 
#' (80% power) experiments, providing guidance for experimental design.
#'
#' @export
identify_cell_range_cpp <- function(min_reads_per_cell, max_reads_per_cell, fc_expression_df, UMI_per_cell, variation, MOI = 10.0, num_targets = 100L, gRNAs_per_target = 4L, non_targeting_gRNAs = 10L, control_group = "complement", multiple_testing_alpha = 0.05, side = "left", prop_non_null = 0.1, min_power_threshold = 0.01, max_power_threshold = 0.8, cell_lower_bound = 100.0, cell_upper_bound = 1e5) {
    .Call(`_perturbplan_identify_cell_range_cpp`, min_reads_per_cell, max_reads_per_cell, fc_expression_df, UMI_per_cell, variation, MOI, num_targets, gRNAs_per_target, non_targeting_gRNAs, control_group, multiple_testing_alpha, side, prop_non_null, min_power_threshold, max_power_threshold, cell_lower_bound, cell_upper_bound)
}

#' Compute effective library size from read depth using UMI saturation curve (C++)
#'
#' @description
#' C++ implementation of the saturation-magnitude (S-M) curve that relates 
#' sequencing reads to unique UMI counts, accounting for PCR amplification 
#' variability and UMI saturation.
#'
#' @param reads_per_cell Numeric vector. Total reads per cell.
#' @param UMI_per_cell Numeric. Maximum UMI per cell parameter from S-M curve fit.
#' @param variation Numeric. Variation parameter characterizing PCR bias from S-M curve fit.
#'
#' @return Numeric vector. Effective library size in UMIs for each read depth.
#'
#' @details
#' This C++ implementation provides significant performance improvements over the R version
#' for large-scale power analysis computations. The S-M curve formula:
#' \deqn{effective\_UMI = UMI\_per\_cell \times (1 - exp(-reads\_per\_cell / UMI\_per\_cell) \times (1 + variation \times reads\_per\_cell^2 / (2 \times UMI\_per\_cell^2)))}
#'
#' @seealso \code{\link{fit_read_UMI_curve}} for R version
#' @export
fit_read_UMI_curve_cpp <- function(reads_per_cell, UMI_per_cell, variation) {
    .Call(`_perturbplan_fit_read_UMI_curve_cpp`, reads_per_cell, UMI_per_cell, variation)
}

#' Identify optimal reads per cell range for power analysis grid (C++)
#'
#' @description
#' C++ implementation that determines the minimum and maximum reads per cell values 
#' for power analysis grid generation using binary search on the S-M curve.
#'
#' @param experimental_platform String. Experimental platform identifier.
#' @param UMI_per_cell Numeric. Maximum UMI per cell parameter.
#' @param variation Numeric. Variation parameter for S-M curve.
#'
#' @return List with min_reads_per_cell and max_reads_per_cell elements.
#'
#' @details
#' This C++ implementation uses efficient binary search to find the reads per cell
#' that achieves approximately 80% UMI saturation. Platform-specific minimums:
#' - "10x Chromium v3": 500 reads/cell
#' - "Other": 1000 reads/cell
#' - Default: 500 reads/cell
#'
#' @seealso \code{\link{identify_library_size_range}} for R version
#' @export
identify_library_size_range_cpp <- function(experimental_platform, UMI_per_cell, variation) {
    .Call(`_perturbplan_identify_library_size_range_cpp`, experimental_platform, UMI_per_cell, variation)
}

#' Generate reads per cell grid using S-M curve analysis (C++)
#'
#' @description
#' Convenience function that combines range identification with grid generation
#' for power analysis heatmaps.
#'
#' @param experimental_platform String. Experimental platform identifier.
#' @param UMI_per_cell Numeric. Maximum UMI per cell parameter.
#' @param variation Numeric. Variation parameter for S-M curve.
#' @param grid_size Integer. Number of points in the grid (default: 10).
#'
#' @return NumericVector. Sequence of reads per cell values for grid.
#'
#' @export
generate_reads_grid_cpp <- function(experimental_platform, UMI_per_cell, variation, grid_size = 10L) {
    .Call(`_perturbplan_generate_reads_grid_cpp`, experimental_platform, UMI_per_cell, variation, grid_size)
}

#' Compute overall power for power analysis (C++)
#'
#' @description
#' C++ implementation of compute_power_plan_overall that provides significant 
#' performance improvements for power analysis computations.
#'
#' @param fc_expression_df DataFrame with fold change and expression info
#' @param library_size Numeric. Effective library size
#' @param num_trt_cells Numeric. Number of treatment cells  
#' @param num_cntrl_cells Numeric. Number of control cells
#' @param multiple_testing_alpha Numeric. FDR target level (default 0.05)
#' @param multiple_testing_method String. Method ("BH" only supported)
#' @param side String. Test sidedness ("left", "right", "both")
#' @param prop_non_null Numeric. Proportion of non-null hypotheses (default 0.1)
#' @param return_full_results Logical. Return full results or just overall power
#'
#' @return Numeric overall power (if return_full_results=FALSE) or List with full results
#'
#' @details
#' This C++ implementation orchestrates existing optimized C++ functions:
#' \itemize{
#'   \item compute_monte_carlo_teststat_cpp(): Monte Carlo test statistics
#'   \item compute_BH_plan(): Benjamini-Hochberg significance cutoff
#'   \item rejection_computation_cpp(): Power calculations
#' }
#' 
#' The function provides identical results to the R version while offering
#' significant performance improvements by eliminating R function call overhead.
#'
#' @seealso \code{\link{compute_power_plan_overall}} for R version
#' @export
compute_power_plan_overall_cpp <- function(fc_expression_df, library_size, num_trt_cells, num_cntrl_cells, multiple_testing_alpha = 0.05, multiple_testing_method = "BH", side = "left", prop_non_null = 0.1, return_full_results = FALSE) {
    .Call(`_perturbplan_compute_power_plan_overall_cpp`, fc_expression_df, library_size, num_trt_cells, num_cntrl_cells, multiple_testing_alpha, multiple_testing_method, side, prop_non_null, return_full_results)
}

#' Compute power for a single experimental design point (C++)
#'
#' @description
#' Lightweight C++ function that computes power for a single cell count and 
#' read depth combination. Optimized for use in binary search algorithms for 
#' cell range determination.
#'
#' @param num_cells Numeric. Total number of cells in the experiment
#' @param reads_per_cell Numeric. Sequencing reads per cell
#' @param fc_expression_df DataFrame with fold change and expression info
#' @param UMI_per_cell Numeric. Maximum UMI per cell parameter from S-M curve
#' @param variation Numeric. Variation parameter from S-M curve
#' @param MOI Numeric. Multiplicity of infection (default 10)
#' @param num_targets Integer. Number of targets (default 100)
#' @param gRNAs_per_target Integer. gRNAs per target (default 4)
#' @param non_targeting_gRNAs Integer. Non-targeting gRNAs (default 10)
#' @param control_group String. Control group type ("complement" or "nt_cells", default "complement")
#' @param multiple_testing_alpha Numeric. FDR target level (default 0.05)
#' @param side String. Test sidedness ("left", "right", "both", default "left")
#' @param prop_non_null Numeric. Proportion of non-null hypotheses (default 0.1)
#'
#' @return Numeric. Overall power for the specified experimental design point
#'
#' @details
#' This function efficiently computes power for a single experimental condition by:
#' \itemize{
#'   \item Converting read depth to library size using S-M curve (fit_read_UMI_curve_cpp)
#'   \item Calculating treatment and control cell counts based on experimental design
#'   \item Computing overall power using compute_power_plan_overall_cpp
#' }
#' 
#' The function is designed for use in binary search algorithms that determine 
#' optimal cell count ranges based on power thresholds.
#'
#' @seealso \code{\link{compute_power_plan_overall_cpp}} for full power analysis
#' @export
compute_single_power_cpp <- function(num_cells, reads_per_cell, fc_expression_df, UMI_per_cell, variation, MOI = 10.0, num_targets = 100L, gRNAs_per_target = 4L, non_targeting_gRNAs = 10L, control_group = "complement", multiple_testing_alpha = 0.05, side = "left", prop_non_null = 0.1) {
    .Call(`_perturbplan_compute_single_power_cpp`, num_cells, reads_per_cell, fc_expression_df, UMI_per_cell, variation, MOI, num_targets, gRNAs_per_target, non_targeting_gRNAs, control_group, multiple_testing_alpha, side, prop_non_null)
}

theta_rough_row <- function(Y, row, mu) {
    .Call(`_perturbplan_theta_rough_row`, Y, row, mu)
}

theta_batch_cpp <- function(Y, library_size, rel_expr, rough = FALSE, n_threads = 0L) {
    .Call(`_perturbplan_theta_batch_cpp`, Y, library_size, rel_expr, rough, n_threads)
}

compute_fc_curve_cpp <- function(fc_output_grid, fc_expression_df, library_size, num_trt_cells, num_cntrl_cells, side, cutoff) {
    .Call(`_perturbplan_compute_fc_curve_cpp`, fc_output_grid, fc_expression_df, library_size, num_trt_cells, num_cntrl_cells, side, cutoff)
}

compute_expression_curve_cpp <- function(expr_output_grid, fc_expression_df, library_size, expression_dispersion_curve, num_trt_cells, num_cntrl_cells, side, cutoff) {
    .Call(`_perturbplan_compute_expression_curve_cpp`, expr_output_grid, fc_expression_df, library_size, expression_dispersion_curve, num_trt_cells, num_cntrl_cells, side, cutoff)
}

compute_monte_carlo_teststat_cpp <- function(fc_expression_df, library_size, num_trt_cells, num_cntrl_cells) {
    .Call(`_perturbplan_compute_monte_carlo_teststat_cpp`, fc_expression_df, library_size, num_trt_cells, num_cntrl_cells)
}

